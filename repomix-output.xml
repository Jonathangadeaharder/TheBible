This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
C#/
  AGENTS.MD.simplified
  CLEANCODE.MD
  COORDINATION.MD
  IPC.MD
  PARALLEL.MD
  PATTERNS.MD
  README.md
  STATICANALYSIS.MD
  TESTING.MD
C++/
  CLEANCODE.MD
  COORDINATION.MD
  IPC.MD
  PARALLEL.MD
  PATTERNS.MD
  README.md
  STATICANALYSIS.MD
  TESTING.MD
commands/
  ARCHITECT.MD
  CLEANCODE.MD
  COMMENTS.MD
  COMMIT.MD
  DOCUMENTATION.MD
  PARALLEL.MD
  README.md
  STATICANALYSIS.MD
  TECHNICALDEBT.MD
  TESTING.MD
prompts/
  C#/
    AspNetCoreAgent.md
    EntityFrameworkAgent.md
    TestingAgent.md
  C++/
    CppTestingAgent.md
    ModernCppAgent.md
  Python/
    PythonCleanCodeAgent.md
    PythonDataScienceAgent.md
    PythonTestingAgent.md
  React/
    ReactComponentAgent.md
    ReactTestingAgent.md
Python/
  CLEANCODE.MD
  IPC.MD
  PARALLEL.MD
  PATTERNS.MD
  README.md
  STATICANALYSIS.MD
  TESTING.MD
React/
  CLEANCODE.MD
  COORDINATION.MD
  IPC.MD
  PARALLEL.MD
  PATTERNS.MD
  README.md
  STATICANALYSIS.MD
  TESTING.MD
templates/
  ADR-TEMPLATE.MD
  API-DESIGN-TEMPLATE.MD
  CODE-REVIEW-CHECKLIST.MD
  GUIDELINES-TEMPLATE.MD
  INCIDENT-REPORT-TEMPLATE.MD
  PATTERN-TEMPLATE.MD
ARCHITECT.MD
CLEANCODE.MD
COMMIT.MD
COORDINATION.MD
IPC.MD
PATTERNS.MD
README.md
RESEARCH.MD
RESTRUCTURING_SUMMARY.MD
TEMPLATE.MD
TESTING.MD
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="C#/AGENTS.MD.simplified">
# C# Agent Coordination (Simplified)

## Role Definition

You are the **C# Agent Coordinator**. You help coordinate C# development tasks for human teams by providing guidance on best practices, task breakdown, and workflow suggestions without requiring complex file structures or registries.

## Objective

Provide **practical coordination** for C# development teams, focusing on **essential guidance** rather than complex orchestration.

## Simplified Approach

Instead of requiring complex file structures like:
- `agents/csharp/registry.json`
- `agents/csharp/workflows/`
- `agents/csharp/reports/`
- `agents/csharp/_config/.coordination.yml`

Simply:
1. **Break down tasks** into manageable pieces
2. **Assign roles** based on team member expertise
3. **Provide workflow guidance** as needed
4. **Track progress** through regular check-ins
5. **Resolve conflicts** through discussion

## Key Guidelines

* Focus on **essential coordination** - don't over-engineer
* **Adapt to your team's existing processes** rather than imposing new ones
* **Keep documentation lightweight** - use existing tools like README.md
* **Prefer human judgment** over rigid rules when appropriate
* **Iterate and improve** processes based on team feedback

## When to Use Full Agent System

Only implement the full agent coordination system if:
- You're working with AI agents that require structured coordination
- You have a very large, distributed team with complex interdependencies
- You're building a system that requires automated orchestration

For most human teams, this simplified approach will be more effective and less bureaucratic.
</file>

<file path="C#/CLEANCODE.MD">
# C# Clean Code Guidelines

This document outlines C#-specific clean code principles that build upon the general clean code principles.

## Naming Conventions

### Classes and Interfaces
- Use PascalCase for class names: `UserService`, `FileProcessor`
- Interface names should start with 'I': `IUserRepository`, `IDisposable`
- Use noun phrases for classes: `UserManager`, `FileHandler`

### Methods and Variables
- Use PascalCase for public methods: `CalculateTotal()`, `GetUserById()`
- Use camelCase for private fields and local variables: `userName`, `totalAmount`
- Use descriptive verb-noun combinations for methods: `SaveUser()`, `ValidateInput()`

### Constants and Enums
- Use PascalCase for constants: `public const int MaxRetryAttempts = 3;`
- Use PascalCase for enum names and values: `FileStatus.Active`, `LogLevel.Error`

## C#-Specific Best Practices

### Properties and Fields
- Prefer auto-properties when no custom logic is needed:
  ```csharp
  public string UserName { get; set; }
  ```
- Use private setters for controlled mutability:
  ```csharp
  public string Id { get; private set; }
  ```

### Null Handling
- Use nullable reference types (C# 8.0+) to make null intentions explicit
- Prefer null-forgiving operator `!` only when you're certain about non-null values
- Use null-coalescing operators for concise null handling:
  ```csharp
  var displayName = user?.Profile?.DisplayName ?? "Unknown";
  ```

### Async/Await Patterns
- Always use `async`/`await` instead of `.Result` or `.Wait()`
- Name async methods with `Async` suffix: `GetDataAsync()`, `ProcessFileAsync()`
- Avoid `async void` except for event handlers

### Dependency Injection
- Use constructor injection for required dependencies
- Use property injection only for optional dependencies
- Register services with appropriate lifetimes (Transient, Scoped, Singleton)

### Exception Handling
- Catch specific exceptions rather than generic `Exception`
- Use custom exception types for domain-specific errors
- Don't catch and ignore exceptions silently
- Log exceptions with sufficient context for debugging

## Language-Specific Patterns

### LINQ and Collections
- Use LINQ methods for readable data transformations
- Prefer `IEnumerable<T>` for method parameters to enable deferred execution
- Use collection interfaces (`ICollection<T>`, `IList<T>`) in APIs for flexibility

### String Handling
- Use interpolated strings for readability: `$"Hello {name}"`
- Use `StringBuilder` for concatenating many strings in loops
- Prefer `string.IsNullOrEmpty()` and `string.IsNullOrWhiteSpace()` for validation

### Resource Management
- Implement `IDisposable` for classes managing unmanaged resources
- Use `using` statements for automatic resource disposal
- Prefer `using` declarations (C# 8.0+) for cleaner code:
  ```csharp
  using var fileStream = new FileStream(path, FileMode.Open);
  ```

## Framework-Specific Guidelines

### ASP.NET Core
- Follow the MVC pattern for web applications
- Use middleware for cross-cutting concerns
- Configure services in `Startup.cs` or `Program.cs`
- Use attribute routing for REST APIs
- Validate input at DTO boundaries

### Entity Framework
- Use Code First approach for database modeling
- Prefer eager loading with `Include()` to avoid N+1 problems
- Use migrations for schema changes
- Avoid exposing `DbContext` directly from services

## Testing Considerations

### Unit Testing
- Mock dependencies injected through constructors
- Test one behavior per test method
- Use descriptive test method names following the pattern: `MethodName_StateUnderTest_ExpectedBehavior`

### Integration Testing
- Test database interactions with in-memory providers when possible
- Use WebApplicationFactory for testing ASP.NET Core endpoints
- Isolate tests with transactions that can be rolled back

_Last Updated: 2025-09-21_
_Next Review: 2026-03-21_

## See Also

- [Clean Code Principles](../CLEANCODE.MD)
- [C# Testing Guidelines](./TESTING.MD)
- [C# Architecture Guidelines](./ARCHITECT.MD)
</file>

<file path="C#/COORDINATION.MD">
# C# Development - Human-Centered Workflow

## Key Principle

Focus on effective team collaboration rather than complex agent coordination.

## Simple Workflow Approach

### 1. Task Identification
- Clearly define what needs to be built
- Break down complex features into smaller tasks
- Estimate effort and complexity

### 2. Skill Matching
- Match tasks to team members based on expertise
- Consider learning goals and career development
- Balance workload across the team

### 3. Implementation
- Follow established coding standards
- Use pair programming for complex tasks
- Conduct regular check-ins on progress

### 4. Review & Feedback
- Perform code reviews with constructive feedback
- Test functionality thoroughly
- Ensure code meets acceptance criteria

## Communication Guidelines

### Daily Standups
- What did you work on yesterday?
- What are you working on today?
- Any blockers or impediments?

### Task Handoffs
- Document key decisions and context
- Ensure clear understanding of requirements
- Provide access to relevant resources

### Problem Resolution
- Address issues early before they become blockers
- Involve the right people to solve problems
- Document solutions for future reference

## Tools & Practices

### Recommended Tools
- **Project Management**: Jira, Trello, or Azure DevOps
- **Version Control**: Git with feature branches
- **CI/CD**: GitHub Actions, Azure Pipelines, or Jenkins
- **Communication**: Slack, Teams, or email

### Best Practices
- Keep documentation close to the code
- Write automated tests for critical functionality
- Maintain a clean, readable codebase
- Regular retrospectives to improve processes

## When to Add Complexity

Only consider more complex coordination systems when:
- Team grows beyond 8-10 developers
- Multiple distributed teams are involved
- Regulatory compliance requires detailed tracking
- Current simple approach is proven inadequate

For most teams, this human-centered approach will be more effective than complex agent orchestration.
</file>

<file path="C#/IPC.MD">
# C# Inter-Process Communication - Essentials

## Key Principle

Choose the simplest communication method that meets your needs.

## Common IPC Methods

### HTTP/REST APIs
**Best for**: Web services, microservices, external integrations

```csharp
using Microsoft.AspNetCore.Mvc;

[ApiController]
[Route("api/[controller]")]
public class UserController : ControllerBase
{
    [HttpGet("{id}")]
    public ActionResult<User> GetUser(int id)
    {
        // Get user logic
        return Ok(user);
    }

    [HttpPost]
    public ActionResult<User> CreateUser(CreateUserRequest request)
    {
        // Create user logic
        return CreatedAtAction(nameof(GetUser), new { id = user.Id }, user);
    }
}
```

### SignalR for Real-time Communication
**Best for**: Real-time notifications, chat applications

```csharp
using Microsoft.AspNetCore.SignalR;

public class ChatHub : Hub
{
    public async Task SendMessage(string user, string message)
    {
        await Clients.All.SendAsync("ReceiveMessage", user, message);
    }
}

// In Startup.cs
public void ConfigureServices(IServiceCollection services)
{
    services.AddSignalR();
}
```

### Named Pipes
**Best for**: Windows inter-process communication

```csharp
using System.IO.Pipes;

// Server
using var server = new NamedPipeServerStream("mypipe");
server.WaitForConnection();
using var writer = new StreamWriter(server);
writer.WriteLine("Hello from server");

// Client
using var client = new NamedPipeClientStream(".", "mypipe", PipeDirection.InOut);
client.Connect();
using var reader = new StreamReader(client);
string response = reader.ReadLine();
```

## Quick Reference

| Method | Use Case | Complexity |
|--------|----------|------------|
| HTTP/REST | Web services | Low |
| SignalR | Real-time | Medium |
| Named Pipes | Windows IPC | Low |
| Message Queues | Async processing | Medium-High |
| gRPC | High-performance | Medium |

## Implementation Guidelines

### For Web Services
1. Use ASP.NET Core Web API
2. Implement proper error handling
3. Use middleware for cross-cutting concerns
4. Secure endpoints with authentication

### For Real-time Features
1. Use SignalR for .NET applications
2. Handle connection lifecycle events
3. Implement reconnection logic
4. Scale with Redis backplane if needed

### For Internal Communication
1. Prefer direct method calls within same process
2. Use interfaces for loose coupling
3. Apply dependency injection
4. Consider performance implications

## Security Considerations

1. **Authentication**: Validate all requests
2. **Authorization**: Check permissions
3. **Encryption**: Use HTTPS/TLS
4. **Input Validation**: Sanitize all inputs
</file>

<file path="C#/PARALLEL.MD">
# C# Parallel Programming Guidelines

C# provides rich parallel programming capabilities through Task Parallel Library (TPL), async/await, and PLINQ.

## Task-Based Parallelism

### Task Creation
```csharp
// Prefer Task.Run for CPU-bound work
var task = Task.Run(() => ComputeExpensiveResult());

// Use async/await for I/O-bound operations
public async Task<string> FetchDataAsync()
{
    using var client = new HttpClient();
    return await client.GetStringAsync("https://api.example.com/data");
}
```

### Task Coordination
```csharp
// Use WhenAll for independent tasks
var tasks = urls.Select(url => DownloadAsync(url)).ToArray();
var results = await Task.WhenAll(tasks);

// Use WhenAny for racing operations
var winner = await Task.WhenAny(task1, task2, task3);
```

## Data Parallelism with PLINQ

```csharp
// Parallel LINQ operations
var results = data
    .AsParallel()
    .Where(x => IsPrime(x))
    .Select(x => Transform(x))
    .ToArray();

// Specify degree of parallelism
var results = data
    .AsParallel()
    .WithDegreeOfParallelism(Environment.ProcessorCount)
    .Select(ProcessItem)
    .ToArray();
```

## Thread Safety

### Immutable Objects
```csharp
public record User(string Name, int Age); // Thread-safe by default

// Use readonly collections
public static ReadOnlyCollection<Item> Items { get; } =
    new List<Item>(initialItems).AsReadOnly();
```

### Synchronization Primitives
```csharp
// Use Concurrent collections
private readonly ConcurrentDictionary<string, User> _users =
    new ConcurrentDictionary<string, User>();

// Lock-free operations with Interlocked
private int _counter = 0;
public void Increment() => Interlocked.Increment(ref _counter);

// ReaderWriterLockSlim for read-heavy scenarios
private readonly ReaderWriterLockSlim _lock = new ReaderWriterLockSlim();
```

## Async/Await Best Practices

### Avoid Async Void
```csharp
// Good - returns Task
public async Task ProcessAsync() { /* ... */ }

// Bad - no way to await or catch exceptions
public async void ProcessAsync() { /* ... */ }
```

### ConfigureAwait Usage
```csharp
// Library code - avoid context capture
await task.ConfigureAwait(false);

// UI code - preserve context for UI updates
await task.ConfigureAwait(true); // or just await task
```

## Common Pitfalls

### Blocking on Async Code
```csharp
// Bad - can cause deadlocks
var result = asyncMethod().Result;

// Good - stay async all the way
var result = await asyncMethod();
```

### Capturing ExecutionContext
```csharp
// Be careful with ambient context
using (ExecutionContext.SuppressFlow())
{
    // Operations that shouldn't inherit context
}
```

## Performance Guidelines

- Use `ValueTask` for synchronous fast-paths
- Prefer `Task.WhenAll` over sequential awaits
- Use `CancellationToken` for cooperative cancellation
- Profile to identify actual bottlenecks
- Consider `IAsyncEnumerable` for streaming data

## Testing Parallel Code

- Use `Task.Delay` instead of `Thread.Sleep`
- Test cancellation scenarios
- Verify thread safety with concurrent access
- Stress test under various loads
</file>

<file path="C#/PATTERNS.MD">
# C# Design Patterns - Essentials

## Key Principle

Focus on understanding patterns conceptually rather than memorizing complex implementations.

## Essential Patterns

### Strategy Pattern
**When to use**: Switch between different algorithms at runtime

```csharp
public interface IPaymentStrategy
{
    bool ProcessPayment(decimal amount);
}

public class CreditCardPayment : IPaymentStrategy
{
    public bool ProcessPayment(decimal amount)
    {
        Console.WriteLine($"Processing credit card payment of ${amount}");
        return true;
    }
}

public class PaymentProcessor
{
    private IPaymentStrategy _strategy;

    public void SetStrategy(IPaymentStrategy strategy)
    {
        _strategy = strategy;
    }

    public bool ExecutePayment(decimal amount)
    {
        return _strategy.ProcessPayment(amount);
    }
}
```

### Observer Pattern
**When to use**: Notify multiple objects of state changes

```csharp
public interface IObserver
{
    void Update(string message);
}

public class Subject
{
    private List<IObserver> _observers = new List<IObserver>();

    public void Attach(IObserver observer)
    {
        _observers.Add(observer);
    }

    public void Notify(string message)
    {
        foreach (var observer in _observers)
        {
            observer.Update(message);
        }
    }
}
```

## Quick Reference

| Pattern | Problem | When to Use |
|---------|---------|-------------|
| Strategy | Switch algorithms | Multiple approaches for same task |
| Observer | Notifications | One-to-many dependencies |
| Factory | Object creation | Complex instantiation logic |
| Singleton | Single instance | Shared resource (use sparingly) |

## Learning Approach

1. Understand the problem each pattern solves
2. Recognize common scenarios where patterns apply
3. Practice with simple examples
4. Apply selectively - don't force patterns where not needed
</file>

<file path="C#/README.md">
# C# Development Guidelines

## Overview

Essential guidelines and patterns for C# development.

## Contents

- **PATTERNS.MD**: Essential design patterns with practical examples
- **IPC.MD**: Inter-process communication methods for C# applications
- **Other guides**: Clean code, testing, static analysis, and parallel processing
- **COORDINATION.MD**: Human-centered workflow for C# development teams
- **prompts/**: Specialized C# agent personas (ASP.NET Core, Entity Framework, Testing)

## Getting Started

1. Review the design patterns for common solutions
2. Understand IPC options for your application architecture
3. Follow clean code principles in your implementations

## Key Principles

- Prefer simplicity over complexity
- Use modern C# features (nullable reference types, pattern matching, etc.)
- Follow .NET coding conventions
- Write testable code with clear separation of concerns
</file>

<file path="C#/STATICANALYSIS.MD">
# C# Static Analysis Tools

This document outlines the best static analysis tools for C# that can be used via MCP or CLI.

## 1. SonarScanner for .NET

**Category**: Multi-category analysis (bugs, vulnerabilities, code smells)
**Integration**: CLI, CI/CD
**MCP Support**: Via command execution

### Installation
```bash
dotnet tool install --global dotnet-sonarscanner
```

### Usage
```bash
dotnet sonarscanner begin /k:"project-key" /d:sonar.login="token"
dotnet build
dotnet sonarscanner end /d:sonar.login="token"
```

### Key Features
- Detects bugs, vulnerabilities, and code smells
- Security hotspot identification
- Code coverage integration
- Technical debt metrics
- Supported languages: C#, VB.NET, C, C++, JavaScript, TypeScript

## 2. ReSharper Command Line Tools (JetBrains)

**Category**: Code quality, refactoring suggestions
**Integration**: CLI
**MCP Support**: Via command execution

### Installation
Download from JetBrains website or use:
```bash
# Via NuGet
nuget install JetBrains.ReSharper.CommandLineTools
```

### Usage
```bash
# Inspect code
jb inspectcode YourSolution.sln --output=inspection.xml

# Cleanup code
jb cleanupcode YourSolution.sln
```

### Key Features
- Code quality analysis
- Code style enforcement
- Dead code detection
- Redundancy identification
- Solution-wide analysis

## 3. Microsoft Code Analysis (FxCopAnalyzers)

**Category**: Code quality, design guidelines
**Integration**: NuGet package, MSBuild
**MCP Support**: Via build execution

### Installation
```xml
<!-- In .csproj file -->
<PackageReference Include="Microsoft.CodeAnalysis.NetAnalyzers" Version="7.0.0">
  <PrivateAssets>all</PrivateAssets>
  <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
</PackageReference>
```

### Usage
```bash
# Automatically runs during build
dotnet build

# Run standalone
dotnet build /p:RunAnalyzers=true
```

### Key Features
- .NET design guidelines enforcement
- Performance optimization suggestions
- Security vulnerability detection
- Interoperability best practices
- Portability analysis

## 4. StyleCop Analyzers

**Category**: Style and consistency
**Integration**: NuGet package, MSBuild
**MCP Support**: Via build execution

### Installation
```xml
<PackageReference Include="StyleCop.Analyzers" Version="1.2.0-beta.435">
  <PrivateAssets>all</PrivateAssets>
  <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets>
</PackageReference>
```

### Usage
```bash
# Configure rules in stylecop.json
dotnet build
```

### Key Features
- Style consistency enforcement
- Documentation requirements
- Layout and spacing rules
- Readability improvements
- Maintainability focus

## 5. Security Code Scan

**Category**: Security vulnerability detection
**Integration**: NuGet package, MSBuild
**MCP Support**: Via build execution

### Installation
```xml
<PackageReference Include="SecurityCodeScan.VS2019" Version="5.6.7">
  <PrivateAssets>all</PrivateAssets>
  <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets>
</PackageReference>
```

### Usage
```bash
dotnet build
```

### Key Features
- OWASP Top 10 vulnerability detection
- Cryptographic weakness identification
- Input validation issues
- Injection flaw detection
- Configuration security checks

## 6. Roslynator

**Category**: Code analysis and refactoring
**Integration**: CLI, Visual Studio extension
**MCP Support**: Via command execution

### Installation
```bash
dotnet tool install --global roslynator.dotnet.cli
```

### Usage
```bash
# Analyze solution
roslynator analyze YourSolution.sln

# Fix issues
roslynator fix YourSolution.sln
```

### Key Features
- 500+ analyzers and refactorings
- Performance improvements
- Code simplification suggestions
- Redundancy elimination
- Modern C# feature adoption

## 7. NDepend

**Category**: Architecture and complexity analysis
**Integration**: CLI, Visual Studio extension
**MCP Support**: Via command execution

### Installation
Download from NDepend website and install.

### Usage
```bash
# Run analysis
ndepend.console.exe NDependProject.ndproj
```

### Key Features
- Architecture quality metrics
- Dependency cycle detection
- Code complexity analysis
- Technical debt calculation
- Quality gates enforcement

## Recommended Tool Combination

For comprehensive C# static analysis, we recommend using the following combination:

1. **Microsoft Code Analysis** - Built-in .NET analyzer for design guidelines
2. **SonarScanner** - Multi-category analysis with security focus
3. **ReSharper CLI Tools** - Code quality and redundancy detection
4. **Security Code Scan** - Specialized security vulnerability detection

## CI/CD Integration Example

```yaml
# GitHub Actions example
- name: Setup .NET
  uses: actions/setup-dotnet@v3
  with:
    dotnet-version: '6.0.x'

- name: Restore dependencies
  run: dotnet restore

- name: Build with code analysis
  run: dotnet build --no-restore

- name: Run SonarScanner
  run: |
    dotnet sonarscanner begin /k:"your-project-key" /d:sonar.login="${{ secrets.SONAR_TOKEN }}"
    dotnet build
    dotnet sonarscanner end /d:sonar.login="${{ secrets.SONAR_TOKEN }}"

- name: Run ReSharper InspectCode
  run: jb inspectcode YourSolution.sln --output=results.xml
```

## MCP Integration Approach

For MCP integration, you can execute these tools via command line and parse their output:

```csharp
// Example MCP command execution
var process = new Process
{
    StartInfo = new ProcessStartInfo
    {
        FileName = "dotnet",
        Arguments = "build /p:RunAnalyzers=true",
        RedirectStandardOutput = true,
        RedirectStandardError = true,
        UseShellExecute = false
    }
};

process.Start();
var output = process.StandardOutput.ReadToEnd();
process.WaitForExit();
```

## Configuration Tips

1. **Rule Sets**: Customize rules in .ruleset files for Microsoft analyzers
2. **Suppression**: Use #pragma warning disable for legitimate exceptions
3. **Baseline**: Create suppression files for existing issues in legacy code
4. **Performance**: Limit analysis scope for large solutions during development
5. **Integration**: Configure different rule severities for build vs. IDE analysis
</file>

<file path="C#/TESTING.MD">
# C# Testing Guide

> **Note**: For general testing principles and common anti-patterns to avoid, please refer to the main [TESTING.MD](../TESTING.MD) file.

## State-of-the-Art Testing Frameworks

### Unit Testing Framework
**xUnit.net** - The most modern and widely adopted testing framework for .NET

### Mocking Framework
**Moq** - The most popular and mature mocking framework for .NET

## Installation

```bash
dotnet add package xunit
dotnet add package xunit.runner.visualstudio
dotnet add package Moq
```

## Unit Test Example

```csharp
using Xunit;
using Moq;
using System;

public class UserServiceTests
{
    [Fact(Timeout = 60000)]
    public void GetUserById_WhenUserExists_ReturnsUser()
    {
        // Arrange
        var mockRepository = new Mock<IUserRepository>();
        var expectedUser = new User { Id = 1, Name = "John Doe" };
        mockRepository.Setup(repo => repo.GetById(1)).Returns(expectedUser);

        var userService = new UserService(mockRepository.Object);

        // Act
        var result = userService.GetUserById(1);

        // Assert
        Assert.NotNull(result);
        Assert.Equal("John Doe", result.Name);
        mockRepository.Verify(repo => repo.GetById(1), Times.Once);
    }

    [Theory(Timeout = 60000)]
    [InlineData(0)]
    [InlineData(-1)]
    public void GetUserById_WhenInvalidId_ThrowsArgumentException(int invalidId)
    {
        // Arrange
        var userService = new UserService(Mock.Of<IUserRepository>());

        // Act & Assert
        Assert.Throws<ArgumentException>(() => userService.GetUserById(invalidId));
    }
}
```

## Integration Test Example

```csharp
using Xunit;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using System.Threading.Tasks;

[Collection("DatabaseCollection")]
public class UserRepositoryIntegrationTests
{
    private readonly DatabaseFixture _fixture;

    public UserRepositoryIntegrationTests(DatabaseFixture fixture)
    {
        _fixture = fixture;
    }

    [Fact(Timeout = 300000)]
    public async Task GetById_WhenUserExists_ReturnsUserFromDatabase()
    {
        // Arrange
        var userId = await _fixture.CreateTestUserAsync("Jane Doe");

        // Act
        var user = await _fixture.UserRepository.GetById(userId);

        // Assert
        Assert.NotNull(user);
        Assert.Equal("Jane Doe", user.Name);
    }
}
```

## End-to-End Test Example

```csharp
using Xunit;
using System.Threading.Tasks;

public class UserEndToEndTests
{
    [Fact(Timeout = 600000)]
    public async Task FullUserWorkflow_CompletesSuccessfully()
    {
        // Arrange
        var testUser = new UserRegistrationDto
        {
            Name = "Test User",
            Email = "test@example.com"
        };

        // Act
        var userId = await CreateUserViaApi(testUser);
        var retrievedUser = await GetUserViaApi(userId);
        var success = await DeleteUserViaApi(userId);

        // Assert
        Assert.True(userId > 0);
        Assert.Equal(testUser.Name, retrievedUser.Name);
        Assert.True(success);
    }
}
```

## Best Practices

1. Follow the AAA pattern (Arrange, Act, Assert)
2. Use descriptive test method names
3. One assertion per test when possible
4. Mock external dependencies
5. Use Theory for parametrized tests
6. Separate unit and integration tests in different projects
7. Use in-memory databases for integration tests when possible
8. **Always set timeouts: 1 minute for unit tests, 5 minutes for integration tests, 10 minutes for end-to-end tests**
9. Use Timeout attribute to prevent tests from hanging indefinitely
10. Monitor test execution times to identify performance regressions
11. **Keep unit tests concise: maximum 10 lines of code (LOC), up to 20 LOC with explanatory comment**

## Mocking Anti-Patterns to Avoid

1. **The Mockery**: Avoid excessive mocking that tests mock interactions rather than real behavior. This often indicates classes with too many dependencies.

2. **Overusing Mocks for Implementation Details**: Don't mock to assert on internal calls or private behaviors. Focus on testing observable outcomes rather than implementation specifics.

3. **Leaky Mocks**: Ensure mocks don't leak between tests. Each test should have isolated mock configurations to maintain consistency.

4. **Mocking Everything Indiscriminately**: Don't mock all dependencies by default. Use mocks sparingly for true isolation, preferring fakes or stubs for simpler simulations.

Focus on testing behavior over internals. If mocking feels excessive, it might signal design issues like classes with too many responsibilities.
</file>

<file path="C++/CLEANCODE.MD">
# C++ Clean Code Guidelines

This document outlines clean code principles specifically for C++ development, building upon the general principles in `/CLEANCODE.MD`.

## Key C++ Principles

### 1. Modern C++ Features
- Prefer `auto` for type deduction to improve readability
- Use range-based for loops when possible
- Leverage smart pointers (`std::unique_ptr`, `std::shared_ptr`) for automatic memory management
- Apply move semantics (`std::move`, rvalue references) for performance

### 2. RAII (Resource Acquisition Is Initialization)
- Manage resources through constructors and destructors
- Never use raw `new` and `delete` - use containers and smart pointers
- Ensure exception safety through proper resource management

### 3. Const Correctness
- Use `const` liberally for parameters, return values, and member functions
- Apply `constexpr` for compile-time constants and functions
- Prefer `const&` for function parameters to avoid unnecessary copies

### 4. Header Organization
- Use header guards (`#pragma once` or `#ifndef/#define/#endif`)
- Minimize `#include` statements in header files
- Prefer forward declarations when possible
- Follow consistent include ordering (C standard, C++ standard, project headers)

## C++-Specific Clean Code Practices

### Naming Conventions
```cpp
// Classes and structs: PascalCase
class UserManager { };

// Functions and variables: camelCase
void calculateTotalPrice();

// Constants: kCamelCase or UPPER_SNAKE_CASE
const int kMaxBufferSize = 1024;
const double PI_CONSTANT = 3.14159;

// Private members: trailing underscore
class Example {
private:
    int count_;
    std::string name_;
};
```

### Function Design
```cpp
// Good: Small, focused functions
double calculateArea(double radius) {
    return PI_CONSTANT * radius * radius;
}

// Good: Clear parameter names
void processData(const std::vector<int>& input_data,
                std::vector<int>& output_results);

// Avoid: Long parameter lists
void badFunction(int a, int b, int c, int d, int e, int f, int g);
```

### Class Design
```cpp
// Good: Clear separation of concerns
class BankAccount {
public:
    // Constructor initializes all members
    explicit BankAccount(double initial_balance);

    // Const-correct member functions
    double getBalance() const;

    // Clear, focused methods
    void deposit(double amount);
    bool withdraw(double amount);

private:
    // Private helper methods
    bool isValidAmount(double amount) const;

    double balance_;
    int account_number_;
};
```

### Error Handling
```cpp
// Good: Use exceptions for error conditions
class FileHandler {
public:
    explicit FileHandler(const std::string& filename) {
        file_.open(filename);
        if (!file_.is_open()) {
            throw std::runtime_error("Failed to open file: " + filename);
        }
    }

private:
    std::ifstream file_;
};

// Good: RAII for resource management
class DatabaseConnection {
public:
    DatabaseConnection() {
        connection_ = connectToDatabase();
        if (!connection_) {
            throw std::runtime_error("Failed to connect to database");
        }
    }

    ~DatabaseConnection() {
        if (connection_) {
            disconnectFromDatabase(connection_);
        }
    }

    // Disable copy constructor and assignment
    DatabaseConnection(const DatabaseConnection&) = delete;
    DatabaseConnection& operator=(const DatabaseConnection&) = delete;

private:
    DatabaseHandle* connection_;
};
```

## C++ Anti-Patterns to Avoid

### 1. Raw Pointer Management
```cpp
// Bad: Manual memory management
int* ptr = new int(42);
// ... use ptr ...
delete ptr; // Easy to forget!

// Good: Smart pointers
auto ptr = std::make_unique<int>(42);
// Automatic cleanup when ptr goes out of scope
```

### 2. Macro Overuse
```cpp
// Bad: Complex macros
#define MAX(a,b) ((a) > (b) ? (a) : (b))

// Good: Inline functions or templates
template<typename T>
inline T max_value(const T& a, const T& b) {
    return (a > b) ? a : b;
}
```

### 3. Using Namespace std
```cpp
// Bad: Polluting global namespace
using namespace std;

// Good: Explicit qualification
std::vector<std::string> names;
std::cout << "Hello World" << std::endl;
```

## Performance Considerations

### 1. Move Semantics
```cpp
// Good: Return by value with move semantics
std::vector<int> createLargeVector() {
    std::vector<int> result(1000000);
    // ... populate result ...
    return result; // Automatically moved
}

// Good: Move when transferring ownership
std::unique_ptr<Data> processData(std::unique_ptr<Data> input) {
    // ... process input ...
    return input; // Automatically moved
}
```

### 2. Avoid Unnecessary Copies
```cpp
// Good: Pass by const reference for large objects
void processString(const std::string& text) {
    // ... process text without copying ...
}

// Good: Reserve space when size is known
std::vector<int> buildVector(int size) {
    std::vector<int> result;
    result.reserve(size); // Avoid reallocations
    for (int i = 0; i < size; ++i) {
        result.push_back(i);
    }
    return result;
}
```

## Testing Considerations

### 1. Dependency Injection
```cpp
// Good: Interface for testing
class DatabaseInterface {
public:
    virtual ~DatabaseInterface() = default;
    virtual bool save(const Record& record) = 0;
    virtual std::optional<Record> load(int id) = 0;
};

class MockDatabase : public DatabaseInterface {
public:
    bool save(const Record& record) override {
        // Mock implementation for testing
        return true;
    }

    std::optional<Record> load(int id) override {
        // Mock implementation for testing
        return std::nullopt;
    }
};
```

## Quick Reference

| Principle | Recommendation |
|-----------|----------------|
| Memory Management | Use smart pointers, RAII |
| Performance | Apply move semantics, reserve vectors |
| Safety | Use const correctness, avoid macros |
| Readability | Prefer auto, clear naming |
| Testing | Design for dependency injection |
</file>

<file path="C++/COORDINATION.MD">
# C++ Development - Human-Centered Workflow

## Key Principle

Focus on effective systems programming team collaboration rather than complex agent coordination.

## Simple Workflow Approach

### 1. System Design
- Define architecture and component interfaces
- Plan memory management and resource usage
- Consider performance and safety requirements

### 2. Implementation Planning
- Break down system into manageable modules
- Assign modules based on team expertise
- Plan integration points and dependencies

### 3. Development
- Follow modern C++ best practices
- Use RAII for resource management
- Conduct regular code reviews and check-ins

### 4. Testing & Integration
- Write unit tests for critical components
- Perform integration testing
- Validate performance and memory usage

## Communication Guidelines

### Daily Standups
- What did you work on yesterday?
- What are you working on today?
- Any blockers or impediments?

### Code Handoffs
- Document APIs and usage examples
- Ensure clear understanding of performance requirements
- Provide build and testing instructions

### Problem Resolution
- Address issues early before they become blockers
- Involve domain experts for complex problems
- Document solutions for future reference

## Tools & Practices

### Recommended Tools
- **Project Management**: Jira, Trello, or Azure DevOps
- **Version Control**: Git with feature branches
- **CI/CD**: GitHub Actions, GitLab CI, or Jenkins
- **Build Systems**: CMake, Bazel, or Meson
- **Communication**: Slack, Teams, or email

### Best Practices
- Prefer stack allocation over heap allocation
- Use smart pointers for dynamic memory
- Follow the Rule of Five for resource management
- Apply const correctness consistently
- Write performance-aware code
- Regular retrospectives to improve processes

## When to Add Complexity

Only consider more complex coordination systems when:
- Team grows beyond 8-10 developers
- Multiple distributed teams are involved
- Safety-critical systems require detailed tracking
- Current simple approach is proven inadequate

For most teams, this human-centered approach will be more effective than complex agent orchestration.
</file>

<file path="C++/IPC.MD">
# C++ Inter-Process Communication - Essentials

## Key Principle

Choose the right IPC mechanism based on performance, complexity, and platform requirements.

## Common IPC Methods

### TCP Sockets
**Best for**: Network communication, cross-platform IPC

```cpp
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <iostream>

// Server example
int createServer(int port) {
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in address;
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(port);

    bind(server_fd, (struct sockaddr*)&address, sizeof(address));
    listen(server_fd, 3);

    return server_fd;
}

// Client example
int connectToServer(const char* ip, int port) {
    int sock = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in serv_addr;
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(port);
    inet_pton(AF_INET, ip, &serv_addr.sin_addr);

    connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));

    return sock;
}
```

### Shared Memory
**Best for**: High-performance local IPC

```cpp
#include <sys/shm.h>
#include <sys/ipc.h>

// Create shared memory segment
int createSharedMemory(size_t size) {
    key_t key = ftok("shmfile", 65);
    int shmid = shmget(key, size, 0666|IPC_CREAT);
    return shmid;
}

// Attach to shared memory
void* attachSharedMemory(int shmid) {
    void* shared_memory = shmat(shmid, nullptr, 0);
    return shared_memory;
}
```

### Message Queues
**Best for**: Asynchronous communication

```cpp
#include <sys/msg.h>
#include <cstring>

struct Message {
    long msg_type;
    char data[256];
};

// Send message
void sendMessage(int msgid, const char* data) {
    Message msg;
    msg.msg_type = 1;
    strcpy(msg.data, data);
    msgsnd(msgid, &msg, sizeof(msg.data), 0);
}

// Receive message
void receiveMessage(int msgid, char* buffer) {
    Message msg;
    msgrcv(msgid, &msg, sizeof(msg.data), 1, 0);
    strcpy(buffer, msg.data);
}
```

## Quick Reference

| Method | Use Case | Platform | Complexity |
|--------|----------|----------|------------|
| TCP Sockets | Network IPC | Cross-platform | Medium |
| Shared Memory | High-performance | Unix/Linux | Medium |
| Message Queues | Async communication | Unix/Linux | Medium |
| Named Pipes | Local IPC | Windows | Low |
| REST APIs | Web services | Cross-platform | Low-Medium |

## Implementation Guidelines

### For Network Communication
1. Handle connection errors gracefully
2. Implement proper buffering
3. Use non-blocking I/O for performance
4. Close connections properly

### For Local IPC
1. Use appropriate synchronization primitives
2. Handle cleanup in signal handlers
3. Validate data integrity
4. Consider security implications

### For Cross-Platform Solutions
1. Use portable libraries like Boost.Asio
2. Abstract platform-specific code
3. Test on all target platforms
4. Handle endianness differences

## Modern C++ Libraries

### REST Client with libcurl
```cpp
#include <curl/curl.h>

size_t WriteCallback(void* contents, size_t size, size_t nmemb, std::string* response) {
    size_t realsize = size * nmemb;
    response->append((char*)contents, realsize);
    return realsize;
}

std::string httpGet(const std::string& url) {
    CURL* curl = curl_easy_init();
    std::string response;

    if (curl) {
        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);
        curl_easy_perform(curl);
        curl_easy_cleanup(curl);
    }

    return response;
}
```

## Best Practices

1. **Error Handling**: Always check return values
2. **Resource Management**: Use RAII for sockets and memory
3. **Security**: Validate all input data
4. **Performance**: Buffer appropriately and avoid unnecessary copies
</file>

<file path="C++/PARALLEL.MD">
# C++ Parallel Programming Guidelines

C++ provides multiple approaches to parallel programming including std::thread, std::async, and parallel algorithms.

## Threading Fundamentals

### Basic Thread Creation
```cpp
#include <thread>
#include <iostream>

void worker(int id) {
    std::cout << "Worker " << id << " running\n";
}

// Create and join threads
std::thread t1(worker, 1);
std::thread t2(worker, 2);
t1.join();
t2.join();
```

### RAII Thread Management
```cpp
class ThreadGuard {
    std::thread& t;
public:
    explicit ThreadGuard(std::thread& t_) : t(t_) {}
    ~ThreadGuard() {
        if (t.joinable()) t.join();
    }
};

// Usage
std::thread t(worker);
ThreadGuard guard(t);
```

## Modern C++ Parallel Features

### std::async and Futures
```cpp
#include <future>

// Fire and forget
auto future = std::async(std::launch::async, computeExpensiveResult);

// Get result (blocks until completion)
auto result = future.get();

// Launch policy control
auto future = std::async(std::launch::deferred | std::launch::async, task);
```

### Parallel Algorithms (C++17)
```cpp
#include <algorithm>
#include <execution>

// Parallel execution policies
std::sort(std::execution::par, vec.begin(), vec.end());
std::for_each(std::execution::par_unseq, vec.begin(), vec.end(), process);

// Reduce operations
auto sum = std::reduce(std::execution::par, vec.begin(), vec.end(), 0);
```

## Thread Safety Mechanisms

### Atomic Operations
```cpp
#include <atomic>

std::atomic<int> counter{0};

// Atomic operations
counter.fetch_add(1);
counter.load();
counter.store(newValue);

// Memory ordering
counter.store(value, std::memory_order_release);
auto val = counter.load(std::memory_order_acquire);
```

### Mutexes and Locks
```cpp
#include <mutex>

std::mutex mtx;
int shared_data = 0;

void safe_increment() {
    std::lock_guard<std::mutex> lock(mtx);
    ++shared_data;
}

// Unique locks for flexible locking
std::unique_lock<std::mutex> lock(mtx);
// ... operations
lock.unlock(); // Explicit unlock
```

### Lock-Free Data Structures
```cpp
#include <shared_mutex>

class ThreadSafeContainer {
    mutable std::shared_mutex mtx;
    std::vector<int> data;

public:
    // Multiple readers, exclusive writer
    int read(size_t index) const {
        std::shared_lock lock(mtx);
        return data.at(index);
    }

    void write(size_t index, int value) {
        std::unique_lock lock(mtx);
        data.at(index) = value;
    }
};
```

## Smart Concurrency Patterns

### Producer-Consumer
```cpp
#include <queue>
#include <condition_variable>

template<typename T>
class ThreadSafeQueue {
private:
    mutable std::mutex mtx;
    std::queue<T> data_queue;
    std::condition_variable data_cond;

public:
    void push(T item) {
        std::lock_guard<std::mutex> lock(mtx);
        data_queue.push(item);
        data_cond.notify_one();
    }

    T pop() {
        std::unique_lock<std::mutex> lock(mtx);
        data_cond.wait(lock, [this]{ return !data_queue.empty(); });
        T item = data_queue.front();
        data_queue.pop();
        return item;
    }
};
```

### Thread Pool
```cpp
class ThreadPool {
private:
    std::vector<std::thread> workers;
    std::queue<std::function<void()>> tasks;
    std::mutex queue_mutex;
    std::condition_variable condition;
    bool stop;

public:
    ThreadPool(size_t num_threads) : stop(false) {
        for (size_t i = 0; i < num_threads; ++i) {
            workers.emplace_back([this] {
                while (true) {
                    std::function<void()> task;
                    {
                        std::unique_lock<std::mutex> lock(queue_mutex);
                        condition.wait(lock, [this]{ return stop || !tasks.empty(); });
                        if (stop && tasks.empty()) return;
                        task = std::move(tasks.front());
                        tasks.pop();
                    }
                    task();
                }
            });
        }
    }

    template<class F>
    auto enqueue(F&& f) -> std::future<typename std::result_of<F()>::type> {
        using return_type = typename std::result_of<F()>::type;

        auto task = std::make_shared<std::packaged_task<return_type()>>(
            std::forward<F>(f)
        );

        std::future<return_type> res = task->get_future();
        {
            std::unique_lock<std::mutex> lock(queue_mutex);
            if (stop) throw std::runtime_error("enqueue on stopped ThreadPool");
            tasks.emplace([task](){ (*task)(); });
        }
        condition.notify_one();
        return res;
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex);
            stop = true;
        }
        condition.notify_all();
        for (std::thread &worker: workers) worker.join();
    }
};
```

## Best Practices

### Exception Safety
```cpp
void worker_thread() {
    try {
        // Do work
    } catch (...) {
        // Handle or store exception for main thread
        std::current_exception();
    }
}
```

### Resource Management
```cpp
// Use RAII for thread-local resources
thread_local std::unique_ptr<Resource> local_resource;

// Proper cleanup in destructors
~Class() {
    stop_flag = true;
    condition.notify_all();
    if (worker_thread.joinable()) {
        worker_thread.join();
    }
}
```

## Performance Considerations

- Minimize lock contention with fine-grained locking
- Use lock-free data structures when possible
- Consider false sharing in cache lines
- Profile before optimizing parallel code
- Be aware of thread creation overhead

## Testing Parallel Code

- Use sanitizers (ThreadSanitizer)
- Test with varying thread counts
- Verify race condition detection
- Stress test with high concurrency
- Test graceful shutdown scenarios
</file>

<file path="C++/PATTERNS.MD">
# C++ Design Patterns - Essentials

## Key Principle

Focus on RAII and modern C++ features rather than complex pattern implementations.

## Essential Patterns

### RAII (Resource Acquisition Is Initialization)
**When to use**: Automatic resource management

```cpp
#include <fstream>
#include <memory>

class FileHandler {
private:
    std::ifstream file;

public:
    FileHandler(const std::string& filename) : file(filename) {
        if (!file.is_open()) {
            throw std::runtime_error("Could not open file");
        }
    }

    ~FileHandler() {
        if (file.is_open()) {
            file.close();
        }
    }

    // Delete copy constructor and assignment operator
    FileHandler(const FileHandler&) = delete;
    FileHandler& operator=(const FileHandler&) = delete;
};
```

### Smart Pointers
**When to use**: Automatic memory management

```cpp
#include <memory>

// Unique pointer - exclusive ownership
std::unique_ptr<MyClass> ptr = std::make_unique<MyClass>();

// Shared pointer - shared ownership
std::shared_ptr<MyClass> sharedPtr = std::make_shared<MyClass>();

// Weak pointer - non-owning reference to shared pointer
std::weak_ptr<MyClass> weakPtr = sharedPtr;
```

### Strategy Pattern
**When to use**: Switch between different algorithms

```cpp
#include <iostream>
#include <memory>

// Strategy interface
class PaymentStrategy {
public:
    virtual ~PaymentStrategy() = default;
    virtual bool processPayment(double amount) = 0;
};

// Concrete strategies
class CreditCardPayment : public PaymentStrategy {
public:
    bool processPayment(double amount) override {
        std::cout << "Processing credit card payment of $" << amount << std::endl;
        return true;
    }
};

// Context class
class PaymentProcessor {
private:
    std::unique_ptr<PaymentStrategy> strategy_;

public:
    explicit PaymentProcessor(std::unique_ptr<PaymentStrategy> strategy)
        : strategy_(std::move(strategy)) {}

    bool executePayment(double amount) {
        return strategy_->processPayment(amount);
    }
};
```

## Quick Reference

| Pattern | Problem | When to Use |
|---------|---------|-------------|
| RAII | Resource management | All resource handling |
| Smart Pointers | Memory management | Dynamic allocation |
| Strategy | Algorithm switching | Multiple approaches |
| Observer | Event notification | Loose coupling |

## Modern C++ Guidelines

1. Prefer stack allocation over heap allocation
2. Use smart pointers instead of raw pointers
3. Leverage move semantics for performance
4. Use const correctness consistently
5. Apply the Rule of Five (destructor, copy/move constructor, copy/move assignment)
</file>

<file path="C++/README.md">
# C++ Development Guidelines

## Overview

Essential guidelines and patterns for modern C++ development.

## Contents

- **PATTERNS.MD**: Essential design patterns with RAII focus
- **IPC.MD**: Inter-process communication methods for C++ applications
- **Other guides**: Clean code, testing, static analysis, and concurrency

## Getting Started

1. Master RAII and smart pointers for resource management
2. Understand modern C++ features (auto, move semantics, etc.)
3. Learn appropriate IPC mechanisms for your use case

## Key Principles

- Prefer stack allocation over heap allocation
- Use smart pointers instead of raw pointers
- Follow the Rule of Five for resource management
- Apply const correctness consistently
- Leverage modern C++ features for safer, cleaner code
</file>

<file path="C++/STATICANALYSIS.MD">
# C++ Static Analysis Tools

This document outlines the best static analysis tools for C++ that can be used via MCP or CLI.

## 1. Clang Static Analyzer

**Category**: Bug detection, memory issues
**Integration**: CLI, LLVM/Clang toolchain
**MCP Support**: Via command execution

### Installation
```bash
# Ubuntu/Debian
sudo apt-get install clang-tools

# macOS
brew install llvm

# Windows
# Download from LLVM website
```

### Usage
```bash
# Basic analysis
clang++ --analyze myfile.cpp

# With specific checker
clang++ --analyze -Xanalyzer -analyzer-checker=core.CallAndMessage myfile.cpp

# Generate HTML report
clang++ --analyze -Xanalyzer -analyzer-output=html myfile.cpp
```

### Key Features
- Memory leak detection
- Null pointer dereference detection
- Buffer overflow identification
- Logic error detection
- Cross-platform support

## 2. Cppcheck

**Category**: Bug detection, style issues
**Integration**: CLI, GUI
**MCP Support**: Via command execution

### Installation
```bash
# Ubuntu/Debian
sudo apt-get install cppcheck

# macOS
brew install cppcheck

# Windows
# Download from cppcheck.sourceforge.io
```

### Usage
```bash
# Basic analysis
cppcheck myfile.cpp

# Check all configurations
cppcheck --enable=all myfile.cpp

# Generate XML report
cppcheck --xml myfile.cpp 2> report.xml

# Check specific directories
cppcheck --enable=all --inconclusive src/
```

### Key Features
- Memory leak detection
- Array out of bounds checking
- Resource leak identification
- Style and performance suggestions
- Misra C/C++ compliance checking

## 3. PVS-Studio

**Category**: Multi-category analysis (bugs, security, performance)
**Integration**: CLI, IDE plugins
**MCP Support**: Via command execution

### Installation
Download from PVS-Studio website (commercial tool with free version for open source).

### Usage
```bash
# Analyze CMake project
pvs-studio-analyzer analyze -o project.log

# Convert to readable format
plog-converter -t tasklist -o project.tasks project.log

# Analyze specific files
pvs-studio-analyzer analyze --source-files *.cpp
```

### Key Features
- 400+ diagnostic rules
- OWASP ASVS compliance
- CERT secure coding standard
- CWE classification
- MISRA standards support

## 4. PC-lint/PC-lint Plus (FlexeLint)

**Category**: Code quality, compliance
**Integration**: CLI, IDE plugins
**MCP Support**: Via command execution

### Installation
Commercial tool from Gimpel Software. Download and install from their website.

### Usage
```bash
# Basic analysis
pclp64 co-gcc.lnt myfile.cpp

# Generate HTML report
pclp64 -hs myfile.cpp

# Analyze with specific configuration
pclp64 std.lnt au-misra3.lnt myfile.cpp
```

### Key Features
- MISRA C/C++ compliance
- Customizable warning levels
- False positive suppression
- Cross-reference information
- Flow analysis

## 5. Coverity Static Analysis

**Category**: Security, quality, compliance
**Integration**: CLI, cloud service
**MCP Support**: Via command execution

### Installation
Commercial tool from Synopsys. Available as on-premises or cloud service.

### Usage
```bash
# Configure project
cov-configure --comptype gcc --compiler gcc

# Build and analyze
cov-build --dir cov-int make

# Upload to cloud for analysis
tar czvf myproject.tgz cov-int
# Upload via web interface or API
```

### Key Features
- Deep path exploration
- Security vulnerability detection
- Standards compliance (MISRA, CERT)
- Integration with CI/CD
- Cloud-based analysis

## 6. Infer

**Category**: Bug detection
**Integration**: CLI
**MCP Support**: Via command execution

### Installation
```bash
# Ubuntu/Debian
wget -O infer.tar.xz https://github.com/facebook/infer/releases/latest/download/infer-linux64.tar.xz
tar xf infer.tar.xz
sudo ln -s "$PWD/infer-linux64/bin/infer" /usr/local/bin/infer

# macOS
brew install infer
```

### Usage
```bash
# Analyze compile command
infer run -- make

# Analyze CMake project
infer run -- cmake --build .

# Analyze specific files
infer -- clang++ -c hello.cpp
```

### Key Features
- Null pointer dereference detection
- Resource leak identification
- Memory safety violations
- Concurrency issues
- Facebook-developed analyzer

## 7. CodeSonar

**Category**: Security, quality, compliance
**Integration**: CLI, GUI
**MCP Support**: Via command execution

### Installation
Commercial tool from GrammaTech. Contact for licensing and installation.

### Usage
```bash
# Create project
codesonar create-project myproject

# Analyze with GCC
codesonar analyze myproject gcc myprogram.c

# Analyze with Clang
codesonar analyze myproject clang++ myprogram.cpp
```

### Key Features
- Deep semantic analysis
- Security vulnerability detection
- Standards compliance
- Scalable for large projects
- Detailed visualization

## 8. Klocwork

**Category**: Security, quality, compliance
**Integration**: CLI, IDE plugins, cloud service
**MCP Support**: Via command execution

### Installation
Commercial tool from Perforce. Contact for licensing and installation.

### Usage
```bash
# Analyze project
kwinject make
kwbuildproject --url http://localhost:8080 kwinject.out
kwadmin load myproject mybuildspec.zip
```

### Key Features
- Security vulnerability detection
- Standards compliance (MISRA, CERT)
- Integration with CI/CD
- Cloud and on-premises deployment
- Detailed reporting

## Recommended Tool Combination

For comprehensive C++ static analysis, we recommend using the following combination:

1. **Cppcheck** - Free, comprehensive basic analysis
2. **Clang Static Analyzer** - Integrated with LLVM toolchain
3. **PVS-Studio** - Advanced commercial option with free tier
4. **Infer** - Facebook's powerful open-source analyzer

## CI/CD Integration Example

```yaml
# GitHub Actions example
- name: Install static analysis tools
  run: |
    sudo apt-get update
    sudo apt-get install -y cppcheck clang-tools

- name: Run Cppcheck
  run: |
    cppcheck --enable=all --inconclusive --xml src/ 2> cppcheck-report.xml

- name: Run Clang Static Analyzer
  run: |
    scan-build make

- name: Archive analysis results
  uses: actions/upload-artifact@v3
  if: always()
  with:
    name: static-analysis-reports
    path: |
      cppcheck-report.xml
      ./*/index.html
```

## MCP Integration Approach

For MCP integration, you can execute these tools via command line and parse their output:

```cpp
// Example MCP command execution
#include <cstdlib>
#include <iostream>

int main() {
    int result = std::system("cppcheck --enable=all --xml src/ 2> report.xml");
    if (result == 0) {
        std::cout << "Analysis completed successfully" << std::endl;
    } else {
        std::cout << "Analysis found issues or failed" << std::endl;
    }
    return 0;
}
```

## Configuration Tips

1. **Suppressions**: Use suppression files for third-party code
2. **Performance**: Limit analysis depth for large projects
3. **Incremental**: Use incremental analysis for faster results
4. **Standards**: Enable specific coding standards (MISRA, CERT)
5. **Integration**: Configure different checkers for different build configurations
</file>

<file path="C++/TESTING.MD">
# C++ Testing Guide

> **Note**: For general testing principles and common anti-patterns to avoid, please refer to the main [TESTING.MD](../TESTING.MD) file.

## State-of-the-Art Testing Frameworks

### Unit Testing Framework
**Google Test (gtest)** - Google's widely adopted C++ testing framework

### Mocking Framework
**Google Mock (gmock)** - Part of Google Test, provides powerful mocking capabilities

## Installation

Using vcpkg:
```bash
vcpkg install gtest
```

Using CMake:
```cmake
find_package(GTest REQUIRED)
target_link_libraries(your_target GTest::gtest GTest::gmock)
```

## Unit Test Example

```cpp
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <memory>

// Class under test
class UserService {
public:
    virtual ~UserService() = default;
    virtual std::string getUserById(int id) = 0;
};

class UserServiceImpl : public UserService {
private:
    std::unique_ptr<UserService> userRepository;

public:
    UserServiceImpl(std::unique_ptr<UserService> repo) : userRepository(std::move(repo)) {}

    std::string getUserById(int id) override {
        if (id <= 0) {
            throw std::invalid_argument("Invalid user ID");
        }
        return userRepository->getUserById(id);
    }
};

// Mock class
class MockUserService : public UserService {
public:
    MOCK_METHOD(std::string, getUserById, (int id), (override));
};

// Unit tests
TEST(UserServiceImplTest, GetUserById_WhenValidId_ReturnsUser) {
    // Arrange
    auto mockRepo = std::make_unique<MockUserService>();
    EXPECT_CALL(*mockRepo, getUserById(1))
        .WillOnce(::testing::Return("John Doe"));

    UserServiceImpl service(std::move(mockRepo));

    // Act
    std::string result = service.getUserById(1);

    // Assert
    EXPECT_EQ(result, "John Doe");
}

TEST(UserServiceImplTest, GetUserById_WhenInvalidId_ThrowsException) {
    // Arrange
    auto mockRepo = std::make_unique<MockUserService>();
    UserServiceImpl service(std::move(mockRepo));

    // Act & Assert
    EXPECT_THROW(service.getUserById(0), std::invalid_argument);
    EXPECT_THROW(service.getUserById(-1), std::invalid_argument);
}
```

## Integration Test Example

```cpp
#include <gtest/gtest.h>
#include <fstream>
#include <filesystem>

class FileDatabaseIntegrationTest : public ::testing::Test {
protected:
    std::string testDir;

    void SetUp() override {
        testDir = "/tmp/test_db_" + std::to_string(time(nullptr));
        std::filesystem::create_directory(testDir);
    }

    void TearDown() override {
        std::filesystem::remove_all(testDir);
    }
};

TEST_F(FileDatabaseIntegrationTest, SaveAndLoadUserData_PersistsCorrectly) {
    // Arrange
    std::string filename = testDir + "/users.dat";
    std::string testData = "John Doe,25\nJane Smith,30";

    // Act
    // Save data to file
    std::ofstream outFile(filename);
    outFile << testData;
    outFile.close();

    // Load data from file
    std::ifstream inFile(filename);
    std::string loadedData;
    std::getline(inFile, loadedData);
    inFile.close();

    // Assert
    EXPECT_EQ(testData, loadedData);
}
```

## End-to-End Test Example

```cpp
#include <gtest/gtest.h>
#include <chrono>
#include <thread>

class ApplicationEndToEndTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Setup test environment
        initializeTestEnvironment();
    }

    void TearDown() override {
        // Cleanup test environment
        cleanupTestEnvironment();
    }
};

TEST_F(ApplicationEndToEndTest, FullUserWorkflow_CompletesSuccessfully) {
    // Arrange
    UserRegistrationData testData{"John Doe", "john@example.com"};

    // Act
    auto startTime = std::chrono::steady_clock::now();

    UserId userId = createUserViaUI(testData);
    UserData retrievedUser = retrieveUserViaUI(userId);
    bool deletionSuccess = deleteUserViaUI(userId);

    auto endTime = std::chrono::steady_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::seconds>(endTime - startTime);

    // Assert
    EXPECT_GT(userId, 0);
    EXPECT_EQ(retrievedUser.name, testData.name);
    EXPECT_TRUE(deletionSuccess);
    EXPECT_LT(duration.count(), 600); // 10 minutes timeout
}
```

## Timeout Implementation Strategies

### Using CTest (Recommended)
If using CMake with CTest, you can set timeouts in your CMakeLists.txt:

```cmake
# Set default timeout for all tests
set(CTEST_TEST_TIMEOUT 60) # 1 minute default

# Override for specific tests
set_tests_properties(UnitTest1 PROPERTIES TIMEOUT 60)    # 1 minute
set_tests_properties(IntegrationTest1 PROPERTIES TIMEOUT 300)  # 5 minutes
set_tests_properties(EndToEndTest1 PROPERTIES TIMEOUT 600)     # 10 minutes
```

### Manual Timeout Implementation
For manual timeout checking within tests:

```cpp
#include <chrono>

TEST(ExampleTest, TestWithManualTimeout) {
    auto startTime = std::chrono::steady_clock::now();

    // Your test code here
    performTestOperation();

    auto currentTime = std::chrono::steady_clock::now();
    auto elapsedSeconds = std::chrono::duration_cast<std::chrono::seconds>(
        currentTime - startTime).count();

    // Assert timeout
    ASSERT_LT(elapsedSeconds, 60) << "Test exceeded 1 minute timeout";
}
```

## Best Practices

1. Follow the AAA pattern (Arrange, Act, Assert)
2. Use descriptive test case names
3. One assertion per test when possible
4. Mock external dependencies like databases and network calls
5. Use fixtures for shared test setup
6. Separate unit and integration tests
7. Test edge cases and error conditions
8. Use typed tests for testing templates
9. Keep tests fast and independent
10. **Always enforce timeouts: 1 minute for unit tests, 5 minutes for integration tests, 10 minutes for end-to-end tests**
11. Use CTest or similar test runner with timeout support
12. Monitor test execution times to identify performance regressions
13. Fail fast when tests exceed their time budgets
14. **Keep unit tests concise: maximum 10 lines of code (LOC), up to 20 LOC with explanatory comment**

## Mocking Anti-Patterns to Avoid

1. **The Mockery**: Avoid excessive mocking that tests mock interactions rather than real behavior. This often indicates classes with too many dependencies.

2. **Overusing Mocks for Implementation Details**: Don't mock to assert on internal calls or private behaviors. Focus on testing observable outcomes rather than implementation specifics.

3. **Leaky Mocks**: Ensure mocks don't leak between tests. Each test should have isolated mock configurations to maintain consistency.

4. **Mocking Everything Indiscriminately**: Don't mock all dependencies by default. Use mocks sparingly for true isolation, preferring fakes or stubs for simpler simulations.

Focus on testing behavior over internals. If mocking feels excessive, it might signal design issues like classes with too many responsibilities.
</file>

<file path="commands/ARCHITECT.MD">
# Local Architecture Decision Validation

## Objective

This command ensures your architecture decisions comply with the standards defined in `/ARCHITECT.MD`. It validates ADRs and helps document significant architectural choices during local development.

## Usage

Run this command when creating or reviewing architecture decisions:
```bash
./validate-adr.sh
```

Or as part of your local development workflow:
```bash
npm run validate-architecture
```

---

## Validation Checks

### 1. ADR Validation

**Action:**
- Scan for ADR files in the current project (typically in `docs/adr/` or similar)
- Parse ADR content to validate structure and completeness

**Validation Rules:**
- ADR must follow standard format (Title, Status, Context, Decision, Consequences, Alternatives)
- Status must be one of: Proposed, Accepted, Deprecated, Superseded
- Context section must clearly describe the problem and driving forces
- Decision section must explain the chosen approach
- Consequences section must list both positive and negative outcomes

**Feedback:**
- Reports any incomplete or malformed ADRs with specific issues
- Provides templates for proper ADR formatting
- Suggests improvements to existing ADRs

### 2. Significant Change Detection

**Action:**
- Analyze code changes to identify potential architectural impacts
- Look for modifications to core components, interfaces, or dependencies
- Detect introduction of new technologies or frameworks

**Detection Rules:**
- Changes affecting >10% of codebase
- Modifications to core architectural components
- Introduction of new external dependencies
- Changes to data models or APIs
- Modifications to deployment or infrastructure

**Feedback:**
- Alerts when significant architectural changes are detected without documentation
- Suggests creating an ADR for significant changes
- Recommends appropriate stakeholders for review

### 3. Alternative Analysis Verification

**Action:**
- Check that ADRs include consideration of alternatives
- Verify that rationale for chosen approach is sound
- Ensure trade-offs are clearly documented

**Validation Rules:**
- ADRs should list viable alternatives when practical
- Each alternative should include pros and cons
- Decision rationale should reference specific trade-offs
- Rejected alternatives should have clear reasons for rejection

**Feedback:**
- Suggests additional alternatives when analysis is limited
- Flags insufficient analysis of trade-offs
- Provides guidance on evaluating architectural decisions

### 4. Diagram Validation

**Action:**
- Check for accompanying architecture diagrams
- Validate diagram format and content
- Ensure diagrams align with ADR decisions

**Validation Rules:**
- Significant architectural changes should include diagrams
- Diagrams should follow C4 model when appropriate
- Diagram elements should match described components
- Diagrams should be versioned with ADRs

**Feedback:**
- Suggests creating diagrams for complex architectural changes
- Provides improvements to diagram clarity and completeness
- Ensures diagrams are properly linked from ADRs
- Offers templates for common diagram types

## Output Format

The tool provides clear, actionable feedback:
- **Summary**: Overall compliance status and key findings
- **Issues**: Detailed list of validation failures with file locations
- **Suggestions**: Specific recommendations for improvement
- **Templates**: Ready-to-use templates for proper documentation

## Integration

This validation can be integrated into:
- Local development workflows
- Pre-commit hooks
- IDE plugins
- Code review processes (for guidance only)
</file>

<file path="commands/CLEANCODE.MD">
# Local Clean Code Standards Validation

## Objective

This command ensures your code complies with the clean code standards defined in `/CLEANCODE.MD`. It scans, validates, and reports deviations in source code files to help you maintain quality standards during local development.

## Usage

Run this command before committing code to validate your changes meet clean code standards:
```bash
./validate-clean-code.sh
```

Or as part of your local development workflow:
```bash
npm run validate-code-quality
```

---

## Validation Checks

### 1. Identify Source Files

**Action:**
- Scan the current directory to identify all source code files
- Exclude generated files, test files, and configuration files from analysis
- Focus on files that have been recently modified

### 2. Validate Naming Conventions

**Action:**
- Parse source files to extract variable, function, and class names
- Check names against language-specific conventions

**Validation Rules:**
- Names must be intention-revealing and avoid disinformation
- Avoid noise words (data, info, manager) unless contextually appropriate
- Use pronounceable and searchable names
- Follow language-specific casing conventions (camelCase, PascalCase, snake_case, etc.)

**Feedback:**
- Reports poorly named identifiers with file locations
- Provides suggestions for better names
- Explains why current names are problematic

### 3. Analyze Function Complexity

**Action:**
- Measure function length and cyclomatic complexity
- Count function parameters
- Identify nested conditional statements

**Validation Rules:**
- Functions should be < 50 lines (ideally < 20)
- Cyclomatic complexity should be <= 10
- Function parameters should be <= 3 (ideally <= 2)
- Nesting depth should be <= 3 levels

**Feedback:**
- Reports complex functions with complexity metrics
- Suggests refactoring approaches (extract method, parameter objects, etc.)
- Prioritizes functions that need immediate attention

### 4. Check Comment Quality

**Action:**
- Identify comments in source code
- Analyze comment content and placement
- Detect commented-out code

**Validation Rules:**
- Comments should explain "why" not "what"
- Avoid redundant comments that restate obvious code
- Remove or update outdated comments
- Eliminate commented-out code

**Feedback:**
- Reports low-quality comments with suggestions for improvement
- Identifies commented-out code that should be removed
- Suggests converting comments to better function/variable names

### 5. Validate Formatting Consistency

**Action:**
- Check indentation consistency
- Validate spacing around operators and keywords
- Ensure consistent brace/bracket placement
- Verify line length limits

**Validation Rules:**
- Use consistent indentation (typically 2 or 4 spaces)
- Maintain consistent spacing around operators
- Follow language-specific formatting conventions
- Keep lines reasonably short (generally < 100 characters)

**Feedback:**
- Reports formatting inconsistencies with file locations
- Suggests auto-formatting tools for your language
- Provides specific formatting guidelines

### 6. Identify Code Smells

**Action:**
- Detect duplicated code blocks
- Identify long parameter lists
- Find inappropriate intimacy between classes/modules
- Spot feature envy (functions that use more data from another class)

**Feedback:**
- Reports code smells with refactoring suggestions
- Prioritizes issues based on severity and impact
- Provides links to relevant clean code principles

## Output Format

The tool provides clear, actionable feedback:
- **Summary**: Overall code quality score and key metrics
- **Issues**: Detailed list of violations with file locations and severity
- **Suggestions**: Specific refactoring recommendations
- **Examples**: Sample improvements where applicable

## Integration

This validation can be integrated into:
- Local development workflows
- Pre-commit hooks
- IDE plugins
- Code review processes (for guidance only)
</file>

<file path="commands/COMMENTS.MD">
\# Comment Truth \& Intent Guard Workflow (Why-not-What)



> Drop-in rule for your \*\*Rules\*\* file. Ensures code comments \& docstrings are \*\*truthful, current, and explain the WHY\*\* (rationale, trade-offs, constraints) instead of re-describing the WHAT.



\## Role Definition



You are the \*\*Comment Guard Agent\*\*. You scan code + VCS history to \*\*detect stale/misleading comments\*\*, verify claims against the implementation, and \*\*auto-propose focused fixes\*\* that emphasize \*\*intent, invariants, and trade-offs\*\*.



\## Objective / Purpose



Keep comments \*\*accurate, high-signal, and maintainable\*\* so readers can trust them for design intent, risks, and operational context.



\## General Guidelines



\* \*\*Always\*\* verify comment claims against the codes observable facts (signatures, side effects, exceptions, complexity hints, feature flags, config).

\* \*\*Prefer WHY over WHAT.\*\* Ban comments that restate the line below.

\* \*\*Be minimal-change.\*\* Propose targeted edits; dont rewrite style wholesale.

\* \*\*No secrets/PII\*\* in comments. Reference vault keys or ticket IDs instead.

\* \*\*Language consistency.\*\* Default to English unless repo policy says otherwise.



\## Capabilities



\* Parse \*\*AST/symbols\*\* for supported languages (e.g., C++/CLI, C/C#, Python, TS/JS, PowerShell, Java).

\* Extract \*\*docstrings/Javadoc/TSDoc/Doxygen/PowerShell help\*\*, inline `//` or `#` blocks.

\* Heuristics for \*\*truthfulness \& staleness\*\*:



&nbsp; \* Signature/param/return/exception drift

&nbsp; \* Config/flag/value drift (e.g., comment says timeout 500ms, code is 300ms)

&nbsp; \* \*\*Why-score\*\* vs \*\*What-score\*\* (lexical + structure features)

&nbsp; \* \*\*Blame gap\*\*: code lines changed after comments last edit

&nbsp; \* Concurrency \& error-handling claims vs actual constructs

\* Auto-suggest \*\*WHY-first\*\* rewrites and \*\*TODO\*\* normalization (`TODO(owner,deadline): `).

\* Open PRs with patches + a \*\*Comment Quality Report\*\*.



\## Triggers



\* \*\*Pre-merge\*\* on any file diffs touching code.

\* \*\*Scheduled\*\* weekly sweep for long-lived branches.

\* \*\*On ADR change\*\* touching related modules.



---



\## Step-by-Step Workflow



\### 0) Initialize (idempotent)



\*\*Goal:\*\* Ensure config \& baselines exist.

\*\*Action:\*\* If missing, create:



```

docs/\_comments/guard.yml     # repo policy: language, max line length, TODO format, banned words

docs/reports/

```



\*\*Transition:\*\* Proceed.



\### 1) Build Observed Semantics



\*\*Goal:\*\* Derive facts from code.

\*\*Action:\*\* For each changed file/function:



\* Parse \*\*signature\*\* (name, params, types, return).

\* Detect \*\*side effects\*\* (I/O, network, DB, global state).

\* Collect \*\*exceptions/errors\*\* thrown/returned.

\* Find \*\*concurrency constructs\*\* (locks, atomics, async/await).

\* Extract \*\*constants \& flags\*\* referenced in comments.

\* Approximate \*\*complexity\*\* (loop nesting, recursion markers).

\* Capture \*\*last-modified timestamps\*\* via `git blame`.

&nbsp; \*\*Output:\*\* `observed.json`.



\### 2) Extract Declared Claims



\*\*Goal:\*\* Understand what comments assert.

\*\*Action:\*\* For docstrings/blocks near the symbol:



\* Identify \*\*intent cues\*\* (because, so that, due to, trade-off, constraint, workaround, upstream bug, regulatory).

\* Identify \*\*what-only cues\*\* (restating code, repeating names/values verbatim).

\* Extract \*\*claims\*\*: param meanings, pre/postconditions, invariants, complexity, performance budgets, security/privacy notes, links (ADR/issue).

&nbsp; \*\*Output:\*\* `declared.json`.



\### 3) Compare \& Classify



\*\*Goal:\*\* Detect drift, lies, and low-value comments.

\*\*Action:\*\* For each symbol:



\* \*\*Staleness (S1S3):\*\* comment older than latest code touch in region by > N days (default 30), and signature/logic changed  \*\*Warn/Block\*\*.

\* \*\*Truthfulness (T1T3):\*\* numeric/text mismatch (timeouts, enum names), exceptions not thrown/removed, wrong thread-safety claim  \*\*Block\*\*.

\* \*\*Why-score:\*\* if `why\_score < threshold` \*\*AND\*\* `what\_overlap > 0.6`  \*\*Warn\*\* (explains what, not why).

\* \*\*Help completeness:\*\* public APIs missing param/return/throws docs  \*\*Warn/Block\*\* per policy.

\* \*\*TODO hygiene:\*\* missing owner or deadline  \*\*Warn\*\*.

&nbsp; \*\*Output:\*\* `docs/reports/comment-guard-YYYYMMDD.md`.



\### 4) Auto-Remediation



\*\*Goal:\*\* Propose minimal, high-signal fixes.

\*\*Action:\*\* Generate patches that:



\* Convert what to \*\*WHY templates\*\* (see below).

\* Update mismatched numbers/flags; or mark \*\*VERIFY:\*\* if ambiguous.

\* Sync docstrings with signature (params/returns/exceptions).

\* Normalize \*\*TODO(owner,YYYY-MM-DD)\*\* and link issue IDs.

\* Add references to ADRs/runbooks when comments cite design choices.

&nbsp; Open a PR:

&nbsp; `chore(comments): sync \& add rationale \[comment-guard report #NN]`



\### 5) Gatekeeping



\*\*Goal:\*\* Enforce merge policy.

\*\*Action:\*\* Fail \*\*Blockers\*\* (T2/T3 lies, missing required doc on public APIs). Warn otherwise. Request reviewers (code owner + architecture owner if ADR referenced).



\### 6) Finalize



\*\*Goal:\*\* Keep baseline healthy.

\*\*Action:\*\* Store `last\_pass.json`, update badge \*\*Comments verified: YYYY-MM-DD\*\* in README.



---



\## Best-Practice Checks (enforced)



1\. \*\*WHY-first rule\*\*



&nbsp;  \* Good comments explain \*\*intent, constraints, trade-offs, and invariants\*\*.

&nbsp;  \* Smell: 60% token overlap with local code  probably what.

&nbsp;  \* Require 1 \*\*intent cue\*\* (because/so that/due to/constraint/trade-off).



2\. \*\*Truthfulness \& Specificity\*\*



&nbsp;  \* Numbers/flags/paths in comments must match code or config.

&nbsp;  \* Dont promise complexity/latency without basis; if present, back with link to benchmark/env.



3\. \*\*Public API Doc Completeness\*\*



&nbsp;  \* Docstring includes: \*\*purpose (12 lines), params (units \& constraints), returns, errors/exceptions, side effects, thread-safety, stability (beta/experimental)\*\*.



4\. \*\*Invariants \& Contracts\*\*



&nbsp;  \* Pre/postconditions and invariants near non-obvious logic (sorting assumptions, nullability, ordering, idempotency).



5\. \*\*Concurrency \& Error Handling\*\*



&nbsp;  \* If claiming thread-safe or idempotent, verify constructs or patterns exist.

&nbsp;  \* On retries/timeouts, document \*\*why the values\*\* (budget, SLO, backoff).



6\. \*\*Security/Privacy\*\*



&nbsp;  \* Comments must not reveal secrets/keys.

&nbsp;  \* If discussing PII, include \*\*reason \& control\*\* (masking, region).



7\. \*\*TODO/NOTE style\*\*



&nbsp;  \* `TODO(owner,YYYY-MM-DD): ` or `FIXME(owner,YYYY-MM-DD): `

&nbsp;  \* Must reference \*\*issue/ADR\*\* if non-trivial.



8\. \*\*Style \& Readability\*\*



&nbsp;  \* Complete sentences, no obviously/simply/clearly.

&nbsp;  \* Line length per repo policy.

&nbsp;  \* One language per file unless policy dictates otherwise.



---



\## Tool Usage Guidelines



\* \*\*Parsers:\*\* `tools.ast.parse`, `tools.symbols`, `tools.doc.extract`, `tools.cfg.read`, `tools.ps.help` (for PowerShell comment-based help).

\* \*\*VCS:\*\* `tools.git.blame`, `tools.git.changed\_lines`, `tools.vcs.open\_pr`.

\* \*\*Scoring:\*\* `tools.nlp.overlap` (code vs comment), `tools.nlp.intent\_cues`.

\* \*\*Write scope:\*\* only modify comments/docstrings; never alter logic.



\## Error Handling



\* \*\*Ambiguous mismatch:\*\* flag with `VERIFY:` and open a task rather than guessing.

\* \*\*Parser gaps:\*\* degrade to line-based heuristics; do not block unless high-risk areas (API, security).

\* \*\*Permission errors:\*\* escalate with required repo scopes.



\## Production Guardrails



\* \*\*Blockers:\*\* false claims (values, API behavior), missing docs on public APIs, security/PII leaks.

\* \*\*Change budget:\*\* auto-patch  150 LOC across comments; otherwise advisory PR.

\* \*\*Opt-outs:\*\* allow `// comment-guard: ignore-next` for intentional exceptions (must include reason).



\## Outputs



\* `docs/reports/comment-guard-YYYYMMDD.md` (findings + diffs)

\* Auto-patch PR with comment fixes

\* Repo badge Comments verified: <date>



---



\## WHY-First Templates (used by auto-remediator)



\*\*Function/Method header\*\*



```text

Why: <design intent / constraint / trade-off excerpt>.

Invariants: <must always hold>.

Edge cases: <inputs/conditions worth calling out>.

Errors: <throws/returns and why>.

Concurrency: <thread-safety / idempotency rationale>.

Links: ADR-00NN, issue-123, benchmark.md#foo

```



\*\*Timeout/retry block\*\*



```text

Why: External <service X> p95 is 180220ms; we budget 300ms end-to-end.

Therefore: timeout=250ms, retries=1 (jittered). Exceeding budget triggers fast-fail.

```



\*\*Workaround\*\*



```text

Why: Upstream bug <link>; until fixed, we sanitize input to avoid OOM.

Risk: Potential false negatives; see tests/workaround\_\*.\*

```



---



\## Examples



\*\*Bad (what-only, stale):\*\*



```cpp

// Increment i by 1.

i++;

```



\*\*Good (why-first):\*\*



```cpp

// Why: We increment before hashing to avoid 0 sentinel collisions in bucket 0.

// Invariant: i > 0 for all stored keys.

// Link: ADR-0017 Hashing Conventions.

i++;

```



\*\*Bad (lying):\*\*



```ts

// Timeout is 500ms to keep UI snappy.

const TIMEOUT\_MS = 300;

```



\*\*Auto-fix:\*\*



```ts

// Why: Keep UI responsive while allowing p95(backend)=180220ms; end-to-end budget 300ms.

// Therefore: TIMEOUT\_MS = 300 (no retries on user-initiated actions). See ADR-0021.

const TIMEOUT\_MS = 300;

```



\*\*Bad (public API missing contract):\*\*



```python

def send(batch): pass

```



\*\*Auto-fix (docstring):\*\*



```python

def send(batch):

&nbsp;   """

&nbsp;   Why: Single network roundtrip lowers latency under bursty load.

&nbsp;   Args:

&nbsp;       batch (Iterable\[Message]): 1\_000 items; will be split by size limits.

&nbsp;   Returns:

&nbsp;       Receipt: server-assigned id and accepted count.

&nbsp;   Raises:

&nbsp;       TimeoutError: backend exceeded 300ms budget.

&nbsp;       ValueError: batch is empty.

&nbsp;   Side effects:

&nbsp;       Emits 'client.sent' metric per batch.

&nbsp;   """

```



---



\## File Naming \& Location



\* Rule file: `AGENTS.md` or `.cursor/rules/comment-guard.md`

\* Reports: `docs/reports/`

\* Config: `docs/\_comments/guard.yml`



\## Testing \& Iteration



\* Seed a pilot on 23 services; track \*\*false-positive rate\*\* and \*\*time-to-fix\*\*.

\* Tune thresholds (`why\_score`, overlap %) and ignore patterns.

\* Add CI check `comment-guard` gating merges for Blockers only.
</file>

<file path="commands/COMMIT.MD">
# Local Commit Message Validation

## Objective

This command ensures your commit messages comply with the standards defined in `/COMMIT.MD`. It validates commit messages and helps you write properly formatted commits during local development.

## Usage

Run this command before pushing your commits to validate message quality:
```bash
./validate-commits.sh
```

Or integrate it as a git hook:
```bash
# Install as pre-commit hook
ln -s ../../validate-commits.sh .git/hooks/commit-msg
```

---

## Validation Checks

### 1. Commit Message Analysis

**Action:**
- Parse recent commit messages in your local branch
- Extract commit message components (type, scope, subject, body, footer)

**Validation Rules:**
- Must follow conventional commit format: `<type>(<scope>): <subject>`
- Type must be one of: feat, fix, docs, style, refactor, perf, test, build, ci, chore
- Subject line must be <= 50 characters
- Subject must use imperative mood
- Body lines should be wrapped at 72 characters
- Footer should contain issue references when applicable

**Feedback:**
- Reports any commits with invalid formatting
- Provides specific corrections for each violation
- Shows examples of correctly formatted commit messages
- Suggests improvements to clarity and structure

### 2. Atomic Commit Verification

**Action:**
- Analyze commit content to ensure each represents a single logical change
- Check for mixed concerns (e.g., feature implementation + formatting changes)

**Validation Rules:**
- Each commit should address one issue or feature
- Related changes should be grouped logically
- Avoid commits that mix different types of changes

**Feedback:**
- Identifies commits with mixed concerns
- Suggests squashing or splitting commits as appropriate
- Provides guidance on proper commit grouping
- Recommends when to use `git commit --amend`

### 3. Issue Reference Validation

**Action:**
- Check commit footers for issue references
- Verify referenced issues exist in the issue tracker (if connected)
- Ensure fix commits reference appropriate issues

**Validation Rules:**
- Fix commits should reference existing issues
- Feature commits may reference issues or epics
- Breaking changes must be clearly indicated

**Feedback:**
- Flags commits missing required issue references
- Suggests appropriate issue references based on commit content
- Explains the importance of linking commits to issues
- Provides templates for common reference formats

### 4. Commit Message Enhancement

**Action:**
- Suggest improvements to commit message clarity
- Recommend more descriptive subjects when vague language is detected
- Propose better categorization of changes

**Enhancement Rules:**
- Subjects should clearly indicate the impact of changes
- Bodies should explain the "why" behind changes
- Technical details should be included when relevant

**Feedback:**
- Provides suggestions for improving commit message quality
- Offers templates for common commit types
- Educates on effective commit message practices
- Recommends resources for learning more about commit conventions

## Output Format

The tool provides clear, actionable feedback:
- **Summary**: Overall commit quality score and key metrics
- **Issues**: Detailed list of violations with specific corrections
- **Suggestions**: Recommendations for improvement
- **Examples**: Well-formatted commit messages for reference

## Integration

This validation can be integrated into:
- Local development workflows
- Git commit hooks
- Git push hooks
- IDE plugins
- Editor configurations
</file>

<file path="commands/DOCUMENTATION.MD">
# Documentation Drift Guard Workflow

> **Quick Reference**
> - **Purpose**: To ensure documentation and diagrams accurately reflect the current system state.
> - **Key Activities**: Observe system state, compare with declared state, classify drift, and auto-remediate.
> - **Critical Guardrails**: Always compare observed vs declared state; never silently accept drift above threshold; fail with actionable steps.

Drop-in rule for your **Rules** file. Ensures architecture docs & diagrams **match reality** (code, infra, APIs, data).

## Key Principles

- **Observe system state** (code, infra, runtime metadata)
- **Enforce documentation accuracy** for ADRs, READMEs, and diagrams
- **Detect and remediate drift** continuously
- **Fail with actionable steps** when drift exceeds thresholds

## Role Definition

You are the **Drift Guard Agent**. Compare *Observed State* vs *Declared State* and enforce accuracy.

## General Guidelines

- Always compare Observed vs Declared State
- Never silently accept drift above thresholdfail with actionable steps
- Be prescriptive & minimal-change: generate focused diffs/PRs
- Prefer C4 (Context/Container/Component) diagrams as code
- Respect security & privacy: no secrets in reports

## Capabilities

- Parse repositories, OpenAPI/gRPC specs, DB schemas, IaC, message queues
- Parse ADRs, docs, and diagram sources into normalized graphs
- Compute drift reports with severity and suggested fixes
- Auto-generate patches and create PRs with CI status checks

## Workflow Steps

### 1. Build Observed State
Produce `docs/_drift/observed_state.json` with services, APIs, data, messaging, infra, and integrations.

### 2. Build Declared State
Produce `docs/_drift/declared_state.json` by parsing ADRs, READMEs, diagrams, and OpenAPI files.

### 3. Diff & Classify Drift
Create `docs/reports/doc-drift-YYYYMMDD.md` with drift classification:
- **Blocker**: API/PII/region/IaC topology drift
- **Warn**: internal component shapes, naming
- **Info**: formatting, links

### 4. Auto-Remediation
Generate minimal patches for docs, diagrams, and OpenAPI files.

## Error Handling

- Parse error: degrade gracefully, add "Manual Review Needed" section
- Permission denied: escalate listing required repo paths/scopes
- Diagram render error: commit source, attach ASCII diff, create follow-up task
- Conflicting ADRs: open a *Supersedes* ADR draft

## Quick Reference

- **Key Files**: `docs/_drift/{observed,declared}.json`, `docs/reports/`
- **Thresholds**: Any API/PII/region/IaC topology drift = Blocker
- **Change Budget**: Refuse auto-fix if patch > 300 LOC across docs
- **Write Scope**: Only under `docs/**`

_Last Updated: 2025-09-21_
_Next Review: 2026-03-21_

## See Also

- [Architecture Guidelines](./ARCHITECT.MD)
- [Technical Debt Management](./TECHNICALDEBT.MD)
</file>

<file path="commands/PARALLEL.MD">
# Parallel Programming Guidelines

Parallel programming enables concurrent execution to improve performance but introduces complexity. Follow these principles for safe and effective parallel code.

## Core Principles

1. **Avoid shared mutable state** - Minimize data sharing between threads/tasks
2. **Use immutable data structures** when possible
3. **Prefer higher-level abstractions** over low-level primitives
4. **Design for thread safety** from the start
5. **Measure performance gains** - Parallelism adds overhead

## Common Patterns

### Task Parallelism
- Divide work into independent tasks
- Use thread pools to manage resources
- Avoid blocking operations in parallel tasks

### Data Parallelism
- Apply same operation to different data elements
- Use partitioning strategies for balanced workload
- Minimize synchronization between parallel operations

### Pipeline Parallelism
- Break work into sequential stages
- Each stage processes data independently
- Pass results between stages efficiently

## Key Challenges

### Race Conditions
- Multiple threads accessing shared data simultaneously
- Results depend on thread scheduling
- Solution: Synchronization mechanisms

### Deadlocks
- Threads waiting for each other indefinitely
- Circular resource dependencies
- Solution: Consistent locking order, timeouts

### Performance Issues
- Thread overhead exceeding benefits
- False sharing in CPU caches
- Solution: Appropriate granularity, profiling

## Best Practices

- Start with sequential implementation
- Profile before and after parallelization
- Use appropriate synchronization primitives
- Handle exceptions in parallel code
- Test thoroughly under load
- Document threading assumptions

For language-specific guidelines, see:
- [C# Parallel Guidelines](./C#/PARALLEL.MD)
- [C++ Parallel Guidelines](./C++/PARALLEL.MD)
- [React Parallel Guidelines](./React/PARALLEL.MD)
</file>

<file path="commands/README.md">
# Automated Workflows

This directory contains the "enforcement code" - automated workflows that ensure compliance with the principles defined in the root guideline files.

## Purpose

Each workflow file in this directory defines step-by-step procedures for automated agents to enforce the corresponding standards from the root guideline files:

| Guideline File | Command Workflow | Purpose |
|----------------|------------------|---------|
| [/ARCHITECT.MD](../ARCHITECT.MD) | [ARCHITECT.MD](./ARCHITECT.MD) | Enforce architecture decision records and documentation |
| [/CLEANCODE.MD](../CLEANCODE.MD) | [CLEANCODE.MD](./CLEANCODE.MD) | Enforce clean code standards and practices |
| [/COMMIT.MD](../COMMIT.MD) | [COMMIT.MD](./COMMIT.MD) | Validate commit message format and quality |
| [/TESTING.MD](../TESTING.MD) | [TESTING.MD](./TESTING.MD) | Enforce test coverage, timeouts, and quality standards |

## How It Works

1. **Developer writes code** following the principles in the root guideline files
2. **Changes are submitted** via pull request or push
3. **Automated workflows execute** to validate compliance with standards
4. **Violations are flagged** with specific corrective actions
5. **Corrective measures are taken** automatically or manually
6. **Compliance is verified** before changes are merged

## Workflow Structure

Each command workflow follows a consistent structure:

### Objective
Defines what the workflow aims to accomplish and which guideline it enforces.

### Triggers
Specifies when the workflow executes (e.g., on pull request, push to main branch).

### Step-by-Step Workflow
Detailed procedures including:
- **Actions**: What the workflow does
- **Validation Rules**: Standards being enforced
- **Corrective Actions**: How violations are handled

### Outputs
Describes the workflow's results (status checks, comments, commits, issues).

## Integration

These workflows are designed to integrate with common CI/CD platforms and can be adapted to:
- GitHub Actions
- GitLab CI/CD
- Jenkins Pipelines
- Other automation platforms

Each workflow is self-contained and can be implemented independently based on your toolchain.
</file>

<file path="commands/STATICANALYSIS.MD">
# Static Analysis Tools Guide

This document provides an overview of the best static analysis tools that can be used via MCP or CLI for various programming languages. Each programming language subdirectory contains specific tool recommendations and usage examples.

## Purpose

Static analysis tools help identify potential bugs, security vulnerabilities, code smells, and maintainability issues before code execution. They are essential for maintaining code quality and preventing defects early in the development cycle.

## Language-Specific Guides

For detailed information about static analysis tools for specific programming languages, please refer to the language-specific guides:

- [C# Static Analysis Tools](./C#/STATICANALYSIS.MD)
- [C++ Static Analysis Tools](./C++/STATICANALYSIS.MD)
- [Python Static Analysis Tools](./Python/STATICANALYSIS.MD)
- [React/JavaScript Static Analysis Tools](./React/STATICANALYSIS.MD)

## General Best Practices

1. **Integrate Early**: Incorporate static analysis into your development workflow as early as possible
2. **Automate**: Run static analysis tools in CI/CD pipelines to catch issues before merging
3. **Configure Rules**: Customize rule sets to match your team's coding standards
4. **Baseline Existing Issues**: When introducing tools to existing codebases, create baselines to focus on new issues
5. **Regular Updates**: Keep tools updated to benefit from the latest security checks and improvements
6. **Combine Tools**: Use multiple complementary tools for comprehensive coverage
7. **Fail Fast**: Configure builds to fail on critical issues detected by static analysis

## Common Categories of Static Analysis

1. **Syntax and Style Checking**: Enforce coding standards and style guides
2. **Bug Detection**: Identify potential runtime errors and logical flaws
3. **Security Analysis**: Detect security vulnerabilities and unsafe practices
4. **Performance Analysis**: Find potential performance bottlenecks
5. **Maintainability Analysis**: Identify code smells and complexity issues
6. **Dependency Analysis**: Check for vulnerable or outdated dependencies

## Integration Methods

1. **CLI Tools**: Direct command-line execution for local development and CI/CD
2. **MCP Integration**: Model Context Protocol integration for AI-assisted analysis
3. **IDE Plugins**: Real-time feedback during development
4. **Pre-commit Hooks**: Automated checks before code commits
5. **CI/CD Pipeline Integration**: Automated checks during build processes

## Evaluation Criteria

When selecting static analysis tools, consider:

1. **Accuracy**: Low false positive and false negative rates
2. **Performance**: Fast execution times for large codebases
3. **Customizability**: Ability to configure rules and thresholds
4. **Integration Support**: Compatibility with your development environment
5. **Community and Support**: Active maintenance and community backing
6. **Documentation**: Comprehensive guides and examples
7. **Reporting**: Clear and actionable issue reporting
8. **Scalability**: Ability to handle projects of varying sizes
</file>

<file path="commands/TECHNICALDEBT.MD">
# Technical Debt Management

Technical debt represents the implied cost of additional rework caused by choosing quick solutions over better approaches. Effective management prevents system degradation and maintains development velocity.

## Key Principles

1. **Make debt visible** - Record all technical debt in a central register
2. **Measure impact** - Assess business and technical consequences
3. **Prioritize ruthlessly** - Focus on high-impact items first
4. **Pay down continuously** - Allocate 15-20% of development time for debt reduction
5. **Prevent accumulation** - Use reviews and automation to catch debt early

## Types of Technical Debt

- **Design Debt**: Poor architectural decisions
- **Code Debt**: Violations of clean code principles
- **Test Debt**: Insufficient or poor-quality tests
- **Documentation Debt**: Missing or outdated documentation
- **Platform Debt**: Outdated dependencies or technologies

## Identification Sources

Check findings from:
- [STATICANALYSIS.MD](STATICANALYSIS.MD) - Code quality and security issues
- [CLEANCODE.MD](CLEANCODE.MD) - Code quality violations
- [TESTING.MD](TESTING.MD) - Test coverage and quality gaps
- [ARCHITECT.MD](ARCHITECT.MD) - Architectural violations
- [DOCUMENTATION.MD](DOCUMENTATION.MD) - Documentation gaps

## Management Workflow

### 1. Document
Record each debt item with:
- Clear description
- Impact assessment (High/Medium/Low)
- Estimated effort to resolve
- Business justification

### 2. Prioritize
Use impact vs. effort matrix:
- High Impact/Low Effort: Address immediately
- High Impact/High Effort: Plan strategically
- Low Impact/Low Effort: Fix during routine work
- Low Impact/High Effort: Defer or avoid

### 3. Integrate
Add debt items to product backlog alongside features. Treat high-impact debt as user stories with clear acceptance criteria.

### 4. Prevent
- Code reviews to catch new debt
- Static analysis in CI/CD pipelines
- Pair programming for complex changes
- Regular retrospectives to identify patterns

## Refactoring Strategies

- **Boy Scout Rule**: Always leave code cleaner than found
- **Small Steps**: Make incremental improvements rather than big rewrites
- **Strangler Pattern**: Gradually replace problematic components
- **Parallel Run**: Validate new implementations before switching traffic

## Success Metrics

Track these indicators:
- Bug recurrence rates
- Feature delivery velocity
- Test coverage trends
- Developer onboarding time
- Code quality scores from static analysis tools

Regular technical debt management preserves system health and development velocity while preventing costly rewrites.

## Quick Reference

- **Identification**: Use static analysis, code reviews, and monitoring tools
- **Prioritization**: Impact vs. effort matrix - focus on high impact/low effort items
- **Management**: Allocate 15-20% of development time for debt reduction
- **Prevention**: Code reviews, pair programming, and automated checks
- **Measurement**: Track velocity, bug rates, and code quality metrics

## Technical Debt Classification

1. **Design Debt**: Poor architectural decisions affecting scalability
2. **Code Debt**: Violations of clean code principles reducing maintainability
3. **Test Debt**: Insufficient or poor-quality tests increasing risk
4. **Documentation Debt**: Missing or outdated documentation hindering understanding
5. **Platform Debt**: Outdated dependencies or technologies creating vulnerabilities

_Last Updated: 2025-09-21_
_Next Review: 2026-03-21_

## See Also

- [Clean Code Principles](./CLEANCODE.MD)
- [Static Analysis Guidelines](./STATICANALYSIS.MD)
- [Testing Guidelines](./TESTING.MD)
- [Architecture Guidelines](./ARCHITECT.MD)
</file>

<file path="commands/TESTING.MD">
# Local Testing Standards Validation

## Objective

This command ensures your code complies with the testing standards defined in `/TESTING.MD`. It scans, validates, and reports deviations in test files to help you maintain quality standards locally.

## Usage

Run this command before committing code to validate your tests meet all standards:
```bash
./validate-tests.sh
```

Or as part of your local development workflow:
```bash
npm run validate-tests
```

---

## Validation Checks

### 1. Identify Test Scopes

**Action:**
- Scan the current directory to identify all test files (e.g., `*.test.js`, `*_test.py`, `*Tests.cs`).
- Identify the corresponding source code files to determine the scope for coverage analysis.

### 2. Validate Test Timeouts

**Action:**
- Parse the identified test files to extract the timeout configured for each test case.
- Compare the extracted timeout against the standard values.

**Validation Rules:**
- Unit Test Timeout <= `60000` ms
- Integration Test Timeout <= `300000` ms
- E2E Test Timeout <= `600000` ms

**Feedback:**
- Reports any tests that exceed timeout limits with file names and line numbers.
- Suggests reducing test complexity or increasing timeout with justification.

### 3. Analyze Test Coverage

**Action:**
- Execute the test suite for the current project.
- Generate a test coverage report for the source code.

**Validation Rules:**
- Line Coverage >= `80%`
- Branch Coverage >= `70%`

**Feedback:**
- Reports coverage statistics for each file.
- Highlights specific files and lines that lack coverage and require additional tests.
- Suggests areas where new tests would be most beneficial.

### 4. Verify Test Independence

**Action:**
- Execute the identified tests in a randomized order multiple times.
- If the test suite produces inconsistent results (passing sometimes, failing others), it indicates a dependency on execution order.

**Feedback:**
- Reports any non-deterministic tests with file names and line numbers.
- Provides suggestions for refactoring tests to ensure proper isolation.
- Lists potential shared state or external dependencies causing issues.

### 5. Validate Test Length Constraints

**Action:**
- Parse the identified test files to analyze the line count of each unit test.
- Extract tests that exceed the standard length limits.

**Validation Rules:**
- Unit Test Length <= `10` lines of code (LOC)
- Extended Unit Test Length <= `20` LOC (requires explanatory comment)

**Feedback:**
- Reports any tests that exceed length limits with file names and line numbers.
- For tests between 10-20 LOC, verifies that an explanatory comment in the format `// Extended test: [Reason]` or equivalent language-specific format is present.
- Suggests refactoring approaches to reduce test complexity.

## Output Format

The tool provides clear, actionable feedback:
- **Summary**: Overall compliance status and key metrics
- **Issues**: Detailed list of violations with file locations
- **Suggestions**: Specific recommendations for improvement
- **Examples**: Sample corrections where applicable

## Integration

This validation can be integrated into:
- Local development workflows
- Pre-commit hooks
- IDE plugins
- CI/CD pipelines (for reporting only, no blocking)
</file>

<file path="prompts/C#/AspNetCoreAgent.md">
# System Prompt: ASP.NET Core Specialist Agent

## 1. Persona

You are an expert-level C# and ASP.NET Core developer with 10+ years of experience building scalable, secure, and maintainable web APIs. You are a strict adherent to the principles outlined in the repository's `CLEANCODE.MD` and `TESTING.MD` files. Your primary focus is on writing idiomatic, high-quality code that is easy for other developers to understand and maintain.

## 2. Core Objective

Your objective is to create, modify, or review ASP.NET Core components (Controllers, Middleware, Services, etc.) to meet the given requirements, ensuring that every piece of code adheres to the highest standards of quality, security, and performance.

## 3. Strict Rules & Constraints (Non-negotiable)

- **Always** use `async` and `await` for I/O-bound operations.
- **Never** use `async void` except for top-level event handlers.
- **Always** use dependency injection for services. Never instantiate services directly in a controller.
- **Always** return `IActionResult` or its derivatives (e.g., `Ok()`, `NotFound()`, `BadRequest()`).
- **Always** validate incoming DTOs using data annotations or FluentValidation.
- **Always** include structured logging with correlation IDs for key actions.
- **Never** expose `DbContext` directly from a controller.
- **Always** write unit tests for every new public method, targeting a minimum of 80% line coverage.
- **Always** add XML documentation comments to all public classes and methods.

## 4. Capabilities & Tools

- You can read and write files within the project directory.
- You can execute `dotnet build` and `dotnet test` to validate your changes.
- You can run the static analysis tools defined in `C#/STATICANALYSIS.MD`.
- You can reference any guideline file in the repository to inform your work.

## 5. Output Format

- All code must be enclosed in Markdown code fences (e.g., ` ```csharp `).
- Before providing code, provide a brief, one-paragraph summary of the changes you are about to make.
- After providing code, list the files that were created or modified.
- If you identify a violation of a guideline that you cannot fix, you must explicitly state the violation and recommend a course of action.

## 6. Example Interaction

**User:** "Create a new controller to get a user by ID."

**Your Expected Response:**

I will create a new `UsersController` with a single `GET` endpoint to retrieve a user by their ID. This controller will use dependency injection to get an `IUserRepository` instance, call its `GetByIdAsync` method, and return an `OkObjectResult` with the user data or a `NotFoundResult` if the user does not exist. I will also create a corresponding unit test.

```csharp
// src/Controllers/UsersController.cs
using Microsoft.AspNetCore.Mvc;
using System.Threading.Tasks;

/// <summary>
/// Controller for managing user data.
/// </summary>
[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    private readonly IUserRepository _userRepository;

    public UsersController(IUserRepository userRepository)
    {
        _userRepository = userRepository;
    }

    /// <summary>
    /// Gets a user by their unique identifier.
    /// </summary>
    /// <param name="id">The user's ID.</param>
    /// <returns>The user data if found; otherwise, a 404 Not Found.</returns>
    [HttpGet("{id}")]
    public async Task<IActionResult> GetUserById(int id)
    {
        var user = await _userRepository.GetByIdAsync(id);
        if (user == null)
        {
            return NotFound();
        }
        return Ok(user);
    }
}
```

**Files Modified:**
- `src/Controllers/UsersController.cs`
- `tests/Controllers/UsersControllerTests.cs`
</file>

<file path="prompts/C#/EntityFrameworkAgent.md">
# System Prompt: Entity Framework Specialist Agent

## 1. Persona

You are an expert-level C# and Entity Framework developer with deep knowledge of ORM patterns, database design, and performance optimization. You specialize in creating efficient, maintainable data access layers that follow best practices for entity modeling, querying, and transaction management.

## 2. Core Objective

Your objective is to design, implement, and optimize Entity Framework Core data access components including DbContexts, Entities, Repositories, and Queries. You ensure data integrity, performance, and maintainability while following domain-driven design principles.

## 3. Strict Rules & Constraints (Non-negotiable)

- **Always** use asynchronous methods (`ToListAsync`, `FirstOrDefaultAsync`, etc.) for database operations.
- **Never** use lazy loading in production code.
- **Always** implement the Repository pattern for data access abstractions.
- **Always** use explicit eager loading (`Include`) when related data is needed.
- **Never** expose `DbSet` directly from services or controllers.
- **Always** handle database transactions properly using `TransactionScope` or `DbContext.Database.BeginTransaction`.
- **Always** configure entity relationships using Fluent API in `OnModelCreating`.
- **Always** use value objects and owned entities where appropriate.
- **Always** implement proper error handling for database operations.
- **Always** write integration tests for data access components.

## 4. Capabilities & Tools

- You can read and write files within the project directory.
- You can execute `dotnet ef migrations add` and `dotnet ef database update` for database migrations.
- You can run performance profiling tools and analyze query execution plans.
- You can reference any guideline file in the repository to inform your work.

## 5. Output Format

- All code must be enclosed in Markdown code fences (e.g., ` ```csharp `).
- Before providing code, provide a brief, one-paragraph summary of the changes you are about to make.
- After providing code, list the files that were created or modified.
- If you identify a violation of a guideline that you cannot fix, you must explicitly state the violation and recommend a course of action.

## 6. Example Interaction

**User:** "Create a DbContext for a blog application with posts and comments."

**Your Expected Response:**

I will create a `BlogDbContext` with `Post` and `Comment` entities, configure their relationships using Fluent API, and implement a generic repository pattern. I'll also create the entity models with proper navigation properties and data annotations.

```csharp
// src/Data/BlogDbContext.cs
using Microsoft.EntityFrameworkCore;
using System.Reflection;

public class BlogDbContext : DbContext
{
    public BlogDbContext(DbContextOptions<BlogDbContext> options) : base(options)
    {
    }

    public DbSet<Post> Posts { get; set; }
    public DbSet<Comment> Comments { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.ApplyConfigurationsFromAssembly(Assembly.GetExecutingAssembly());

        modelBuilder.Entity<Post>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Title).IsRequired().HasMaxLength(200);
            entity.Property(e => e.Content).IsRequired();
            entity.HasMany(e => e.Comments)
                  .WithOne(e => e.Post)
                  .HasForeignKey(e => e.PostId)
                  .OnDelete(DeleteBehavior.Cascade);
        });

        modelBuilder.Entity<Comment>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Author).IsRequired().HasMaxLength(100);
            entity.Property(e => e.Content).IsRequired().HasMaxLength(1000);
        });
    }
}
```

**Files Modified:**
- `src/Data/BlogDbContext.cs`
- `src/Models/Post.cs`
- `src/Models/Comment.cs`
</file>

<file path="prompts/C#/TestingAgent.md">
# System Prompt: C# Testing Specialist Agent

## 1. Persona

You are an expert C# testing engineer with deep knowledge of xUnit.net, Moq, and testing best practices. You specialize in creating comprehensive test suites that ensure code quality, reliability, and maintainability while following the testing principles outlined in `TESTING.MD`.

## 2. Core Objective

Your objective is to create, maintain, and improve automated tests for C# applications. You ensure that tests are fast, reliable, isolated, and provide meaningful coverage while adhering to the 10-line limit for unit tests (extendable to 20 lines with justification).

## 3. Strict Rules & Constraints (Non-negotiable)

- **Always** follow the AAA pattern (Arrange, Act, Assert) in tests.
- **Always** use descriptive test method names following the pattern `MethodName_StateUnderTest_ExpectedBehavior`.
- **Always** set appropriate timeouts (1 minute for unit tests, 5 minutes for integration tests).
- **Never** exceed 10 lines of code per unit test (up to 20 lines with explanatory comment).
- **Always** mock external dependencies like databases, file systems, and network calls.
- **Never** share state between tests or depend on execution order.
- **Always** test both happy paths and error conditions.
- **Always** clean up test data and resources in teardown methods.
- **Always** use `Theory` and `InlineData` for parametrized tests.
- **Always** verify mock expectations using `Verify` methods.

## 4. Capabilities & Tools

- You can read and write test files within the project directory.
- You can execute `dotnet test` to validate test suites.
- You can analyze test coverage reports and identify gaps.
- You can reference any guideline file in the repository to inform your work.

## 5. Output Format

- All test code must be enclosed in Markdown code fences (e.g., ` ```csharp `).
- Before providing code, provide a brief, one-paragraph summary of the tests you are about to create.
- After providing code, list the files that were created or modified.
- If you identify test quality issues, you must explicitly state them and recommend improvements.

## 6. Example Interaction

**User:** "Create unit tests for a user service with CRUD operations."

**Your Expected Response:**

I will create unit tests for a `UserService` class covering all CRUD operations. I'll use Moq to mock the `IUserRepository` dependency, follow the AAA pattern, and ensure each test is concise and focused. I'll test both successful operations and error conditions.

```csharp
// tests/Services/UserServiceTests.cs
using Xunit;
using Moq;
using System.Threading.Tasks;
using System;

public class UserServiceTests
{
    [Fact(Timeout = 60000)]
    public async Task GetUserById_WhenUserExists_ReturnsUser()
    {
        // Arrange
        var mockRepository = new Mock<IUserRepository>();
        var expectedUser = new User { Id = 1, Name = "John Doe" };
        mockRepository.Setup(repo => repo.GetByIdAsync(1)).ReturnsAsync(expectedUser);

        var userService = new UserService(mockRepository.Object);

        // Act
        var result = await userService.GetUserByIdAsync(1);

        // Assert
        Assert.NotNull(result);
        Assert.Equal("John Doe", result.Name);
        mockRepository.Verify(repo => repo.GetByIdAsync(1), Times.Once);
    }

    [Fact(Timeout = 60000)]
    public async Task GetUserById_WhenUserDoesNotExist_ThrowsNotFoundException()
    {
        // Arrange
        var mockRepository = new Mock<IUserRepository>();
        mockRepository.Setup(repo => repo.GetByIdAsync(It.IsAny<int>())).ReturnsAsync((User)null);

        var userService = new UserService(mockRepository.Object);

        // Act & Assert
        await Assert.ThrowsAsync<NotFoundException>(() => userService.GetUserByIdAsync(999));
        mockRepository.Verify(repo => repo.GetByIdAsync(999), Times.Once);
    }
}
```

**Files Modified:**
- `tests/Services/UserServiceTests.cs`
</file>

<file path="prompts/C++/CppTestingAgent.md">
# System Prompt: C++ Testing Specialist Agent

## 1. Persona

You are an expert C++ testing engineer with deep knowledge of Google Test (gtest) and Google Mock (gmock). You specialize in creating comprehensive test suites for C++ applications that ensure code quality, reliability, and performance while following the testing principles in `TESTING.MD`.

## 2. Core Objective

Your objective is to create, maintain, and improve automated tests for C++ applications. You ensure that tests are fast, reliable, isolated, and provide meaningful coverage while adhering to the 10-line limit for unit tests (extendable to 20 lines with justification).

## 3. Strict Rules & Constraints (Non-negotiable)

- **Always** follow the AAA pattern (Arrange, Act, Assert) in tests.
- **Always** use descriptive test case names following the pattern `TestCaseName_Scenario_ExpectedBehavior`.
- **Always** set appropriate timeouts using CTest or manual timeout checking.
- **Never** exceed 10 lines of code per unit test (up to 20 lines with explanatory comment).
- **Always** mock external dependencies like databases, file systems, and network calls.
- **Never** share state between tests or depend on execution order.
- **Always** test both happy paths and error conditions.
- **Always** clean up test data and resources in `TearDown` methods.
- **Always** use typed tests for template-heavy code.
- **Always** verify mock expectations using `EXPECT_CALL` and verification macros.

## 4. Capabilities & Tools

- You can read and write test files within the project directory.
- You can execute `ctest` or build and run test executables.
- You can analyze test coverage using gcov or similar tools.
- You can reference any guideline file in the repository to inform your work.

## 5. Output Format

- All test code must be enclosed in Markdown code fences (e.g., ` ```cpp `).
- Before providing code, provide a brief, one-paragraph summary of the tests you are about to create.
- After providing code, list the files that were created or modified.
- If you identify test quality issues, you must explicitly state them and recommend improvements.

## 6. Example Interaction

**User:** "Create unit tests for a simple calculator class with add and divide operations."

**Your Expected Response:**

I will create unit tests for a `Calculator` class covering addition and division operations. I'll use Google Test fixtures for shared setup, test both normal operations and edge cases like division by zero, and ensure each test stays within the 10-line limit.

```cpp
// tests/CalculatorTest.cpp
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include "Calculator.h"

class CalculatorTest : public ::testing::Test {
protected:
    void SetUp() override {
        calculator_ = std::make_unique<Calculator>();
    }

    std::unique_ptr<Calculator> calculator_;
};

TEST_F(CalculatorTest, Add_PositiveNumbers_ReturnsSum) {
    // Arrange
    double a = 5.0;
    double b = 3.0;
    double expected = 8.0;

    // Act
    double result = calculator_->add(a, b);

    // Assert
    EXPECT_DOUBLE_EQ(expected, result);
}

TEST_F(CalculatorTest, Divide_ValidNumbers_ReturnsQuotient) {
    // Arrange
    double dividend = 10.0;
    double divisor = 2.0;
    double expected = 5.0;

    // Act
    double result = calculator_->divide(dividend, divisor);

    // Assert
    EXPECT_DOUBLE_EQ(expected, result);
}

TEST_F(CalculatorTest, Divide_ByZero_ThrowsException) {
    // Arrange
    double dividend = 10.0;
    double divisor = 0.0;

    // Act & Assert
    EXPECT_THROW(calculator_->divide(dividend, divisor), std::invalid_argument);
}
```

**Files Modified:**
- `tests/CalculatorTest.cpp`
</file>

<file path="prompts/C++/ModernCppAgent.md">
# System Prompt: Modern C++ Specialist Agent

## 1. Persona

You are an expert C++ developer with deep knowledge of modern C++ standards (C++11 through C++20) and best practices. You specialize in writing safe, efficient, and maintainable C++ code using RAII, smart pointers, and modern STL features while adhering to the principles in `CLEANCODE.MD` and `TESTING.MD`.

## 2. Core Objective

Your objective is to create, modify, or review C++ code that follows modern best practices, ensures memory safety, maximizes performance, and maintains high code quality. You focus on leveraging C++'s unique strengths while avoiding its pitfalls.

## 3. Strict Rules & Constraints (Non-negotiable)

- **Always** use RAII for resource management.
- **Always** prefer stack allocation over heap allocation when possible.
- **Always** use smart pointers (`std::unique_ptr`, `std::shared_ptr`) for dynamic memory.
- **Never** use raw `new`/`delete` or owning raw pointers.
- **Always** follow the Rule of Five (or Rule of Zero when possible).
- **Always** use `const` correctness consistently.
- **Always** use `auto` for complex type declarations when it improves readability.
- **Always** use `nullptr` instead of `NULL` or `0`.
- **Always** use `enum class` instead of plain enums.
- **Always** write unit tests for every new public function, targeting 80% line coverage.

## 4. Capabilities & Tools

- You can read and write C++ files within the project directory.
- You can execute build commands and compile code with modern C++ compilers.
- You can run static analysis tools like clang-tidy and valgrind.
- You can reference any guideline file in the repository to inform your work.

## 5. Output Format

- All code must be enclosed in Markdown code fences (e.g., ` ```cpp `).
- Before providing code, provide a brief, one-paragraph summary of the changes you are about to make.
- After providing code, list the files that were created or modified.
- If you identify a violation of a guideline that you cannot fix, you must explicitly state the violation and recommend a course of action.

## 6. Example Interaction

**User:** "Create a simple class to represent a bank account with deposit and withdrawal operations."

**Your Expected Response:**

I will create a `BankAccount` class that uses RAII for resource management, follows the Rule of Five, and ensures thread safety for basic operations. I'll use `double` for monetary values (in production code, a proper decimal type would be preferred) and include appropriate error handling.

```cpp
// include/BankAccount.h
#pragma once
#include <string>
#include <mutex>

class BankAccount {
public:
    explicit BankAccount(double initialBalance = 0.0);

    // Rule of Five - explicitly defaulted
    BankAccount(const BankAccount&) = default;
    BankAccount& operator=(const BankAccount&) = default;
    BankAccount(BankAccount&&) noexcept = default;
    BankAccount& operator=(BankAccount&&) noexcept = default;
    ~BankAccount() = default;

    bool deposit(double amount);
    bool withdraw(double amount);
    double getBalance() const;

private:
    mutable std::mutex mutex_;
    double balance_;
};
```

```cpp
// src/BankAccount.cpp
#include "BankAccount.h"
#include <stdexcept>

BankAccount::BankAccount(double initialBalance)
    : balance_(initialBalance < 0.0 ? 0.0 : initialBalance) {}

bool BankAccount::deposit(double amount) {
    if (amount <= 0.0) {
        return false;
    }

    std::lock_guard<std::mutex> lock(mutex_);
    balance_ += amount;
    return true;
}

bool BankAccount::withdraw(double amount) {
    if (amount <= 0.0) {
        return false;
    }

    std::lock_guard<std::mutex> lock(mutex_);
    if (balance_ < amount) {
        return false;
    }

    balance_ -= amount;
    return true;
}

double BankAccount::getBalance() const {
    std::lock_guard<std::mutex> lock(mutex_);
    return balance_;
}
```

**Files Modified:**
- `include/BankAccount.h`
- `src/BankAccount.cpp`
</file>

<file path="prompts/Python/PythonCleanCodeAgent.md">
# System Prompt: Python Clean Code Specialist Agent

## 1. Persona

You are an expert Python developer with deep knowledge of Python best practices, PEP 8 compliance, and clean code principles. You specialize in writing Pythonic, maintainable, and efficient code while following the principles in `Python/CLEANCODE.MD` and `Python/TESTING.MD`.

## 2. Core Objective

Your objective is to create, modify, or review Python code that follows PEP 8 standards, uses Pythonic idioms, incorporates type hints, and maintains high code quality. You focus on leveraging Python's strengths while avoiding common pitfalls.

## 3. Strict Rules & Constraints (Non-negotiable)

- **Always** follow PEP 8 style guide (4 spaces indentation, 79 character lines).
- **Always** use type hints for function parameters and return values.
- **Always** write docstrings for all public modules, functions, classes, and methods.
- **Always** use list comprehensions and generator expressions when appropriate.
- **Always** leverage context managers (`with` statements) for resource management.
- **Never** use mutable default arguments.
- **Always** handle exceptions specifically rather than broadly.
- **Always** use `enumerate()` instead of manual indexing when needed.
- **Always** use `zip()` for parallel iteration.
- **Always** write unit tests for every new function, targeting 80% line coverage.

## 4. Capabilities & Tools

- You can read and write Python files within the project directory.
- You can execute `python -m pytest` to validate tests.
- You can run `black`, `flake8`, and `mypy` for code quality checks.
- You can reference any guideline file in the repository to inform your work.

## 5. Output Format

- All code must be enclosed in Markdown code fences (e.g., ` ```python `).
- Before providing code, provide a brief, one-paragraph summary of the changes you are about to make.
- After providing code, list the files that were created or modified.
- If you identify a violation of a guideline that you cannot fix, you must explicitly state the violation and recommend a course of action.

## 6. Example Interaction

**User:** "Create a utility module for processing user data with validation and transformation functions."

**Your Expected Response:**

I will create a `user_utils.py` module with functions for validating email addresses, transforming user names to a standard format, and processing user data dictionaries. I'll use type hints, proper docstrings, and Pythonic idioms throughout.

```python
"""
Utility functions for processing user data.

This module provides functions for validating, transforming, and processing
user-related data in a consistent and reliable manner.
"""

import re
from typing import Dict, List, Optional
from dataclasses import dataclass


@dataclass
class User:
    """Represents a user with basic information."""
    id: int
    name: str
    email: str
    age: Optional[int] = None


def is_valid_email(email: str) -> bool:
    """
    Validate an email address format.

    Args:
        email: The email address to validate.

    Returns:
        True if the email is valid, False otherwise.
    """
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return bool(re.match(pattern, email))


def standardize_name(name: str) -> str:
    """
    Convert a name to standardized format (title case).

    Args:
        name: The name to standardize.

    Returns:
        The standardized name.
    """
    return ' '.join(word.capitalize() for word in name.strip().split())


def process_users(raw_users: List[Dict[str, str]]) -> List[User]:
    """
    Process raw user data into validated User objects.

    Args:
        raw_users: List of dictionaries containing user data.

    Returns:
        List of validated User objects.

    Raises:
        ValueError: If required fields are missing or invalid.
    """
    processed_users = []

    for i, raw_user in enumerate(raw_users):
        # Validate required fields
        if 'name' not in raw_user or 'email' not in raw_user:
            raise ValueError(f"Missing required fields for user {i}")

        # Validate email
        if not is_valid_email(raw_user['email']):
            raise ValueError(f"Invalid email for user {i}: {raw_user['email']}")

        # Create user object with standardized data
        user = User(
            id=i + 1,
            name=standardize_name(raw_user['name']),
            email=raw_user['email'].lower(),
            age=int(raw_user.get('age', 0)) if raw_user.get('age') else None
        )

        processed_users.append(user)

    return processed_users
```

**Files Modified:**
- `src/utils/user_utils.py`
</file>

<file path="prompts/Python/PythonDataScienceAgent.md">
# System Prompt: Python Data Science Specialist Agent

## 1. Persona

You are an expert Python data scientist with deep knowledge of pandas, NumPy, scikit-learn, and data visualization libraries. You specialize in creating efficient, reproducible data processing pipelines and machine learning models while following Python best practices and clean code principles.

## 2. Core Objective

Your objective is to create, modify, or review Python code for data analysis, processing, and machine learning tasks. You ensure that data workflows are efficient, reproducible, and well-documented while maintaining code quality and following established guidelines.

## 3. Strict Rules & Constraints (Non-negotiable)

- **Always** use pandas for data manipulation and analysis.
- **Always** handle missing data explicitly and document the approach.
- **Always** use scikit-learn for machine learning tasks.
- **Always** split data into training/validation/test sets properly.
- **Always** use cross-validation for model evaluation.
- **Always** document data transformations and feature engineering steps.
- **Always** use appropriate visualization libraries (matplotlib, seaborn) for data exploration.
- **Always** write unit tests for data processing functions.
- **Always** use type hints for complex data structures.
- **Always** follow reproducibility best practices (random seeds, version pinning).

## 4. Capabilities & Tools

- You can read and write Python data science files within the project directory.
- You can execute data processing and ML scripts.
- You can generate visualizations and statistical summaries.
- You can reference any guideline file in the repository to inform your work.

## 5. Output Format

- All code must be enclosed in Markdown code fences (e.g., ` ```python `).
- Before providing code, provide a brief, one-paragraph summary of the analysis or model you are about to create.
- After providing code, list the files that were created or modified.
- If you identify data quality issues, you must explicitly state them and recommend improvements.

## 6. Example Interaction

**User:** "Create a data preprocessing pipeline for a customer dataset with missing values and categorical variables."

**Your Expected Response:**

I will create a preprocessing pipeline using scikit-learn's Pipeline and ColumnTransformer to handle missing values, encode categorical variables, and scale numerical features. I'll include proper documentation and handle edge cases like unknown categories.

```python
"""
Customer data preprocessing pipeline.

This module provides a preprocessing pipeline for customer datasets
that handles missing values, encodes categorical variables, and scales
numerical features.
"""

import pandas as pd
import numpy as np
from sklearn.pipeline import Pipeline
from sklearn.compose import ColumnTransformer
from sklearn.impute import SimpleImputer
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.base import BaseEstimator, TransformerMixin
from typing import List, Tuple


class CustomerDataPreprocessor:
    """Preprocessing pipeline for customer data."""

    def __init__(self, categorical_columns: List[str], numerical_columns: List[str]):
        """
        Initialize the preprocessor.

        Args:
            categorical_columns: List of categorical column names.
            numerical_columns: List of numerical column names.
        """
        self.categorical_columns = categorical_columns
        self.numerical_columns = numerical_columns
        self.preprocessor = None
        self._build_pipeline()

    def _build_pipeline(self):
        """Build the preprocessing pipeline."""
        # Preprocessing for numerical data
        numerical_transformer = Pipeline(steps=[
            ('imputer', SimpleImputer(strategy='median')),
            ('scaler', StandardScaler())
        ])

        # Preprocessing for categorical data
        categorical_transformer = Pipeline(steps=[
            ('imputer', SimpleImputer(strategy='constant', fill_value='missing')),
            ('onehot', OneHotEncoder(handle_unknown='ignore'))
        ])

        # Bundle preprocessing for numerical and categorical data
        self.preprocessor = ColumnTransformer(
            transformers=[
                ('num', numerical_transformer, self.numerical_columns),
                ('cat', categorical_transformer, self.categorical_columns)
            ]
        )

    def fit(self, X: pd.DataFrame):
        """
        Fit the preprocessor on training data.

        Args:
            X: Training data DataFrame.

        Returns:
            self: Fitted preprocessor.
        """
        self.preprocessor.fit(X)
        return self

    def transform(self, X: pd.DataFrame) -> np.ndarray:
        """
        Transform data using the fitted preprocessor.

        Args:
            X: Data to transform.

        Returns:
            Transformed data as numpy array.
        """
        return self.preprocessor.transform(X)

    def fit_transform(self, X: pd.DataFrame) -> np.ndarray:
        """
        Fit the preprocessor and transform the data.

        Args:
            X: Data to fit and transform.

        Returns:
            Transformed data as numpy array.
        """
        return self.preprocessor.fit_transform(X)


def analyze_missing_data(df: pd.DataFrame) -> pd.Series:
    """
    Analyze missing data in a DataFrame.

    Args:
        df: DataFrame to analyze.

    Returns:
        Series with missing data percentages by column.
    """
    missing_counts = df.isnull().sum()
    missing_percentages = 100 * missing_counts / len(df)
    return missing_percentages[missing_percentages > 0].sort_values(ascending=False)
```

**Files Modified:**
- `src/preprocessing/customer_preprocessor.py`
</file>

<file path="prompts/Python/PythonTestingAgent.md">
# System Prompt: Python Testing Specialist Agent

## 1. Persona

You are an expert Python testing engineer with deep knowledge of pytest, unittest.mock, and Python testing best practices. You specialize in creating comprehensive test suites for Python applications that ensure code quality, reliability, and maintainability while following the testing principles in `Python/TESTING.MD`.

## 2. Core Objective

Your objective is to create, maintain, and improve automated tests for Python applications. You ensure that tests are fast, reliable, isolated, and provide meaningful coverage while adhering to the 10-line limit for unit tests (extendable to 20 lines with justification).

## 3. Strict Rules & Constraints (Non-negotiable)

- **Always** use pytest as the testing framework.
- **Always** follow the AAA pattern (Arrange, Act, Assert) in tests.
- **Always** use descriptive test function names following the pattern `test_what_is_being_tested_expected_behavior`.
- **Always** set appropriate timeouts using `@pytest.mark.timeout`.
- **Never** exceed 10 lines of code per unit test (up to 20 lines with explanatory comment).
- **Always** mock external dependencies like databases, APIs, and file systems.
- **Never** share state between tests or depend on execution order.
- **Always** test both happy paths and error conditions.
- **Always** clean up test data and resources using fixtures.
- **Always** use parametrized tests for testing multiple inputs/outputs.

## 4. Capabilities & Tools

- You can read and write test files within the project directory.
- You can execute `pytest` to validate test suites.
- You can analyze test coverage using `pytest-cov`.
- You can reference any guideline file in the repository to inform your work.

## 5. Output Format

- All test code must be enclosed in Markdown code fences (e.g., ` ```python `).
- Before providing code, provide a brief, one-paragraph summary of the tests you are about to create.
- After providing code, list the files that were created or modified.
- If you identify test quality issues, you must explicitly state them and recommend improvements.

## 6. Example Interaction

**User:** "Create tests for a user validation utility module."

**Your Expected Response:**

I will create comprehensive tests for user validation functions using pytest. I'll test email validation with various inputs, name standardization with different formats, and user processing with both valid and invalid data. I'll use parametrized tests for multiple test cases and fixtures for shared setup.

```python
"""
Tests for user utility functions.
"""

import pytest
from src.utils.user_utils import is_valid_email, standardize_name, process_users, User


class TestEmailValidation:
    """Tests for email validation function."""

    @pytest.mark.timeout(1)
    def test_valid_emails(self):
        """Test that valid emails return True."""
        valid_emails = [
            "user@example.com",
            "test.email@domain.co.uk",
            "user+tag@site.org"
        ]

        for email in valid_emails:
            assert is_valid_email(email) is True

    @pytest.mark.timeout(1)
    def test_invalid_emails(self):
        """Test that invalid emails return False."""
        invalid_emails = [
            "invalid.email",
            "@example.com",
            "user@",
            "user.example.com"
        ]

        for email in invalid_emails:
            assert is_valid_email(email) is False


class TestNameStandardization:
    """Tests for name standardization function."""

    @pytest.mark.timeout(1)
    @pytest.mark.parametrize("input_name,expected", [
        ("john doe", "John Doe"),
        ("JOHN DOE", "John Doe"),
        (" john  doe ", "John Doe"),
        ("mary jane-watson", "Mary Jane-Watson")
    ])
    def test_standardize_name_formats(self, input_name, expected):
        """Test name standardization with various inputs."""
        result = standardize_name(input_name)
        assert result == expected


class TestUserProcessing:
    """Tests for user processing function."""

    @pytest.mark.timeout(1)
    def test_process_valid_users(self):
        """Test processing valid user data."""
        raw_users = [
            {"name": "john doe", "email": "john@example.com", "age": "25"},
            {"name": "JANE SMITH", "email": "jane@test.org"}
        ]

        result = process_users(raw_users)

        assert len(result) == 2
        assert isinstance(result[0], User)
        assert result[0].name == "John Doe"
        assert result[0].email == "john@example.com"
        assert result[0].age == 25
        assert result[1].age is None

    @pytest.mark.timeout(1)
    def test_process_invalid_user_data(self):
        """Test processing invalid user data raises ValueError."""
        raw_users = [{"name": "john doe"}]  # Missing email

        with pytest.raises(ValueError, match="Missing required fields"):
            process_users(raw_users)
```

**Files Modified:**
- `tests/test_user_utils.py`
</file>

<file path="prompts/React/ReactComponentAgent.md">
# System Prompt: React Component Specialist Agent

## 1. Persona

You are an expert React developer with deep knowledge of modern React patterns, hooks, context, and state management. You specialize in creating reusable, accessible, and performant React components while following the principles in `CLEANCODE.MD` and `TESTING.MD`.

## 2. Core Objective

Your objective is to create, modify, or review React components that are maintainable, testable, and follow best practices. You focus on component composition, proper state management, and adherence to the React philosophy of unidirectional data flow.

## 3. Strict Rules & Constraints (Non-negotiable)

- **Always** use functional components with hooks instead of class components.
- **Always** follow the Rules of Hooks (only call hooks at the top level, only call hooks from React functions).
- **Always** use TypeScript for type safety in component props and state.
- **Always** destructure props at the beginning of the component function.
- **Always** use `useMemo` and `useCallback` for expensive computations and stable references.
- **Never** mutate state directly; always use setState functions.
- **Always** handle component lifecycle properly with `useEffect`.
- **Always** write unit tests for every new component, targeting 80% line coverage.
- **Always** follow accessibility best practices (aria labels, semantic HTML).
- **Always** keep components small and focused on a single responsibility.

## 4. Capabilities & Tools

- You can read and write React component files within the project directory.
- You can execute `npm test` or `yarn test` to validate component tests.
- You can run ESLint and Prettier for code quality checks.
- You can reference any guideline file in the repository to inform your work.

## 5. Output Format

- All code must be enclosed in Markdown code fences (e.g., ` ```jsx `).
- Before providing code, provide a brief, one-paragraph summary of the component you are about to create.
- After providing code, list the files that were created or modified.
- If you identify a violation of a guideline that you cannot fix, you must explicitly state the violation and recommend a course of action.

## 6. Example Interaction

**User:** "Create a user profile card component that displays user information and allows editing."

**Your Expected Response:**

I will create a `UserProfileCard` component that displays user information and provides an edit mode. I'll use TypeScript for prop typing, implement proper state management with useState, and ensure the component is accessible and testable.

```jsx
// src/components/UserProfileCard/UserProfileCard.tsx
import React, { useState } from 'react';
import './UserProfileCard.css';

interface User {
  id: number;
  name: string;
  email: string;
  avatarUrl?: string;
}

interface UserProfileCardProps {
  user: User;
  onUserUpdate?: (updatedUser: User) => void;
}

const UserProfileCard: React.FC<UserProfileCardProps> = ({ user, onUserUpdate }) => {
  const [isEditing, setIsEditing] = useState(false);
  const [editedUser, setEditedUser] = useState<User>(user);

  const handleEditClick = () => {
    setIsEditing(true);
    setEditedUser(user);
  };

  const handleCancel = () => {
    setIsEditing(false);
    setEditedUser(user);
  };

  const handleSave = () => {
    if (onUserUpdate) {
      onUserUpdate(editedUser);
    }
    setIsEditing(false);
  };

  const handleInputChange = (field: keyof User, value: string) => {
    setEditedUser(prev => ({ ...prev, [field]: value }));
  };

  if (isEditing) {
    return (
      <div className="user-profile-card editing" role="form" aria-label="Edit user profile">
        <div className="profile-header">
          <img
            src={editedUser.avatarUrl || '/default-avatar.png'}
            alt={`${editedUser.name}'s avatar`}
            className="profile-avatar"
          />
          <input
            type="text"
            value={editedUser.name}
            onChange={(e) => handleInputChange('name', e.target.value)}
            aria-label="User name"
            className="edit-name-input"
          />
        </div>
        <div className="profile-content">
          <label htmlFor="email-input">Email:</label>
          <input
            id="email-input"
            type="email"
            value={editedUser.email}
            onChange={(e) => handleInputChange('email', e.target.value)}
            aria-label="User email"
            className="edit-email-input"
          />
        </div>
        <div className="profile-actions">
          <button onClick={handleSave} className="save-button">Save</button>
          <button onClick={handleCancel} className="cancel-button">Cancel</button>
        </div>
      </div>
    );
  }

  return (
    <div className="user-profile-card" role="article" aria-label="User profile">
      <div className="profile-header">
        <img
          src={user.avatarUrl || '/default-avatar.png'}
          alt={`${user.name}'s avatar`}
          className="profile-avatar"
        />
        <h2 className="profile-name">{user.name}</h2>
      </div>
      <div className="profile-content">
        <p className="profile-email">{user.email}</p>
      </div>
      <div className="profile-actions">
        <button onClick={handleEditClick} className="edit-button" aria-label="Edit profile">
          Edit
        </button>
      </div>
    </div>
  );
};

export default UserProfileCard;
```

**Files Modified:**
- `src/components/UserProfileCard/UserProfileCard.tsx`
- `src/components/UserProfileCard/UserProfileCard.css`
</file>

<file path="prompts/React/ReactTestingAgent.md">
# System Prompt: React Testing Specialist Agent

## 1. Persona

You are an expert React testing engineer with deep knowledge of Jest, React Testing Library, and testing best practices. You specialize in creating comprehensive test suites for React applications that ensure component quality, reliability, and user experience while following the testing principles in `TESTING.MD`.

## 2. Core Objective

Your objective is to create, maintain, and improve automated tests for React components and applications. You ensure that tests focus on user behavior rather than implementation details, are fast, reliable, and provide meaningful coverage while adhering to the 10-line limit for unit tests (extendable to 20 lines with justification).

## 3. Strict Rules & Constraints (Non-negotiable)

- **Always** use React Testing Library for component tests (focus on user behavior).
- **Always** follow the AAA pattern (Arrange, Act, Assert) in tests.
- **Always** use descriptive test names that explain user behavior.
- **Always** set appropriate timeouts (1 minute for unit tests, 5 minutes for integration tests).
- **Never** exceed 10 lines of code per unit test (up to 20 lines with explanatory comment).
- **Always** mock external dependencies like API calls and browser APIs.
- **Never** test implementation details (component state, internal methods).
- **Always** test both happy paths and error conditions.
- **Always** clean up mocks and DOM elements between tests.
- **Always** use `async/await` for asynchronous operations.

## 4. Capabilities & Tools

- You can read and write test files within the project directory.
- You can execute `npm test` or `yarn test` to validate test suites.
- You can analyze test coverage reports and identify gaps.
- You can reference any guideline file in the repository to inform your work.

## 5. Output Format

- All test code must be enclosed in Markdown code fences (e.g., ` ```jsx `).
- Before providing code, provide a brief, one-paragraph summary of the tests you are about to create.
- After providing code, list the files that were created or modified.
- If you identify test quality issues, you must explicitly state them and recommend improvements.

## 6. Example Interaction

**User:** "Create tests for a login form component with username and password fields."

**Your Expected Response:**

I will create comprehensive tests for a LoginForm component using React Testing Library. I'll test user interactions like typing in fields and submitting the form, verify error handling for invalid inputs, and ensure proper accessibility attributes are present.

```jsx
// src/components/LoginForm/LoginForm.test.tsx
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import '@testing-library/jest-dom';
import LoginForm from './LoginForm';

describe('LoginForm', () => {
  const mockOnSubmit = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('renders login form with required fields', () => {
    // Arrange & Act
    render(<LoginForm onSubmit={mockOnSubmit} />);

    // Assert
    expect(screen.getByLabelText(/username/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/password/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /sign in/i })).toBeInTheDocument();
  }, 60000);

  test('submits form with valid credentials', async () => {
    // Arrange
    render(<LoginForm onSubmit={mockOnSubmit} />);
    const usernameInput = screen.getByLabelText(/username/i);
    const passwordInput = screen.getByLabelText(/password/i);
    const submitButton = screen.getByRole('button', { name: /sign in/i });

    // Act
    await userEvent.type(usernameInput, 'testuser');
    await userEvent.type(passwordInput, 'password123');
    await userEvent.click(submitButton);

    // Assert
    expect(mockOnSubmit).toHaveBeenCalledWith({
      username: 'testuser',
      password: 'password123'
    });
  }, 60000);

  test('shows error message for empty username', async () => {
    // Arrange
    render(<LoginForm onSubmit={mockOnSubmit} />);
    const submitButton = screen.getByRole('button', { name: /sign in/i });

    // Act
    await userEvent.click(submitButton);

    // Assert
    expect(screen.getByText(/username is required/i)).toBeInTheDocument();
    expect(mockOnSubmit).not.toHaveBeenCalled();
  }, 60000);
});
```

**Files Modified:**
- `src/components/LoginForm/LoginForm.test.tsx`
</file>

<file path="Python/CLEANCODE.MD">
# Python Clean Code Guidelines

This document outlines clean code principles specifically for Python development, building upon the general principles in `/CLEANCODE.MD`.

## Key Python Principles

### 1. PEP 8 Compliance
- Follow PEP 8 style guide for Python code
- Use 4 spaces per indentation level
- Limit lines to 79 characters
- Use blank lines to separate functions and classes

### 2. Pythonic Idioms
- Use list comprehensions and generator expressions
- Leverage context managers (`with` statements)
- Apply unpacking and multiple assignment
- Use built-in functions and libraries when available

### 3. Type Hints
- Use type hints for function parameters and return values
- Apply type hints to complex data structures
- Consider using `typing` module for advanced typing

### 4. Docstrings
- Write docstrings for all public modules, functions, classes, and methods
- Follow PEP 257 for docstring conventions
- Use meaningful, descriptive docstrings

## Python-Specific Clean Code Practices

### Naming Conventions
```python
# Modules and packages: lowercase_with_underscores
import data_processor

# Classes: CapWords (PascalCase)
class UserManager:
    pass

# Functions and variables: lowercase_with_underscores
def calculate_total_price():
    pass

# Constants: UPPERCASE_WITH_UNDERSCORES
MAX_BUFFER_SIZE = 1024
PI_CONSTANT = 3.14159

# Private members: leading underscore
class Example:
    def __init__(self):
        self._internal_count = 0
        self.__very_private = "secret"
```

### Function Design
```python
# Good: Small, focused functions
def calculate_area(radius: float) -> float:
    """Calculate the area of a circle given its radius."""
    return PI_CONSTANT * radius * radius

# Good: Clear parameter names with defaults
def process_data(input_data: list,
                output_format: str = 'json') -> dict:
    """Process input data and return formatted results."""
    # ... process data ...
    return results

# Avoid: Long parameter lists - use kwargs or dataclasses
def bad_function(a, b, c, d, e, f, g, h, i, j):
    pass
```

### Class Design
```python
# Good: Clear separation of concerns
class BankAccount:
    """Represents a bank account with basic operations."""

    def __init__(self, initial_balance: float = 0.0):
        """Initialize account with optional initial balance."""
        self._balance = initial_balance
        self._transactions = []

    @property
    def balance(self) -> float:
        """Get current account balance."""
        return self._balance

    def deposit(self, amount: float) -> None:
        """Deposit money into the account."""
        if amount <= 0:
            raise ValueError("Deposit amount must be positive")
        self._balance += amount
        self._transactions.append(('deposit', amount))

    def withdraw(self, amount: float) -> bool:
        """Withdraw money from the account."""
        if amount <= 0 or amount > self._balance:
            return False
        self._balance -= amount
        self._transactions.append(('withdraw', amount))
        return True

# Good: Dataclasses for simple data containers
from dataclasses import dataclass

@dataclass
class Person:
    name: str
    age: int
    email: str
```

### Error Handling
```python
# Good: Specific exception handling
def read_config_file(filename: str) -> dict:
    """Read configuration from JSON file."""
    try:
        with open(filename, 'r') as file:
            return json.load(file)
    except FileNotFoundError:
        logger.warning(f"Config file {filename} not found, using defaults")
        return {}
    except json.JSONDecodeError as e:
        logger.error(f"Invalid JSON in config file {filename}: {e}")
        raise ValueError(f"Invalid config file format: {filename}")

# Good: Context managers for resource management
def process_file(filename: str) -> str:
    """Process a file and return its contents."""
    with open(filename, 'r', encoding='utf-8') as file:
        return file.read().strip()
```

## Python Anti-Patterns to Avoid

### 1. Mutable Default Arguments
```python
# Bad: Mutable default argument
def bad_function(items=[]):
    items.append("new_item")
    return items

# Good: Use None as default
def good_function(items=None):
    if items is None:
        items = []
    items.append("new_item")
    return items
```

### 2. Deep Nesting
```python
# Bad: Deep nesting
if condition1:
    if condition2:
        if condition3:
            do_something()

# Good: Early returns and guard clauses
if not condition1:
    return
if not condition2:
    return
if not condition3:
    return
do_something()
```

### 3. Broad Exception Handling
```python
# Bad: Catching all exceptions
try:
    risky_operation()
except:
    pass  # Silent failure

# Good: Specific exception handling
try:
    risky_operation()
except SpecificException as e:
    logger.error(f"Operation failed: {e}")
    handle_specific_error(e)
```

## Performance Considerations

### 1. Efficient Data Structures
```python
# Good: Use sets for membership testing
valid_names = {'alice', 'bob', 'charlie'}
if name in valid_names:  # O(1) lookup
    process_name(name)

# Good: Use generators for large datasets
def process_large_file(filename):
    with open(filename) as file:
        for line in file:
            yield process_line(line)
```

### 2. String Concatenation
```python
# Bad: Inefficient string concatenation in loops
result = ""
for item in items:
    result += str(item)  # Creates new string each time

# Good: Use join for multiple concatenations
result = "".join(str(item) for item in items)

# Good: Use format strings for readability
message = f"Hello {name}, you have {count} messages"
```

## Testing Considerations

### 1. Pytest Best Practices
```python
# Good: Clear test naming and structure
def test_bank_account_deposit():
    """Test that deposit increases balance correctly."""
    account = BankAccount(100.0)
    account.deposit(50.0)
    assert account.balance == 150.0

# Good: Parametrized tests
@pytest.mark.parametrize("amount,expected", [
    (100, 200),
    (50, 150),
    (0, 100),
])
def test_deposit_various_amounts(amount, expected):
    account = BankAccount(100.0)
    account.deposit(amount)
    assert account.balance == expected

# Good: Fixtures for test setup
@pytest.fixture
def sample_account():
    return BankAccount(1000.0)

def test_withdraw_success(sample_account):
    result = sample_account.withdraw(100.0)
    assert result is True
    assert sample_account.balance == 900.0
```

## Quick Reference

| Principle | Recommendation |
|-----------|----------------|
| Style | Follow PEP 8 |
| Typing | Use type hints |
| Documentation | Write clear docstrings |
| Error Handling | Be specific with exceptions |
| Performance | Use appropriate data structures |
| Testing | Write focused, isolated tests |
</file>

<file path="Python/IPC.MD">
# Python Inter-Process Communication - Essentials

## Key Principle

Use Python's rich ecosystem of libraries to implement the right IPC mechanism for your needs.

## Common IPC Methods

### HTTP/REST with requests
**Best for**: Web services, APIs, microservices

```python
import requests
import json

# GET request
def get_user(user_id):
    response = requests.get(f'https://api.example.com/users/{user_id}')
    response.raise_for_status()
    return response.json()

# POST request
def create_user(user_data):
    response = requests.post(
        'https://api.example.com/users',
        json=user_data,
        headers={'Content-Type': 'application/json'}
    )
    response.raise_for_status()
    return response.json()

# With session for multiple requests
session = requests.Session()
session.headers.update({'Authorization': 'Bearer token'})
```

### WebSockets with websockets
**Best for**: Real-time communication

```python
import asyncio
import websockets

# WebSocket client
async def websocket_client():
    uri = "ws://localhost:8765"
    async with websockets.connect(uri) as websocket:
        await websocket.send("Hello server!")
        response = await websocket.recv()
        print(f"Received: {response}")

# WebSocket server
async def websocket_handler(websocket, path):
    async for message in websocket:
        await websocket.send(f"Echo: {message}")

start_server = websockets.serve(websocket_handler, "localhost", 8765)
```

### Multiprocessing for Parallel Processing
**Best for**: CPU-intensive tasks, parallel execution

```python
from multiprocessing import Process, Queue, Pool
import os

# Using Process
def worker_function(name):
    print(f'Worker {name} PID: {os.getpid()}')

if __name__ == '__main__':
    processes = []
    for i in range(4):
        p = Process(target=worker_function, args=(i,))
        processes.append(p)
        p.start()

    for p in processes:
        p.join()

# Using Pool
def square_number(n):
    return n * n

if __name__ == '__main__':
    with Pool(4) as pool:
        results = pool.map(square_number, [1, 2, 3, 4, 5])
    print(results)
```

## Quick Reference

| Method | Use Case | Complexity |
|--------|----------|------------|
| requests | HTTP APIs | Low |
| websockets | Real-time | Medium |
| multiprocessing | Parallel tasks | Medium |
| ZeroMQ | Flexible messaging | Medium-High |
| gRPC | High-performance | Medium |

## Implementation Guidelines

### For Web Services
1. Use requests or aiohttp for HTTP clients
2. Handle timeouts and retries appropriately
3. Use sessions for connection pooling
4. Validate and sanitize API responses

### For Real-time Communication
1. Handle connection lifecycle events
2. Implement proper error handling
3. Use asyncio for concurrent connections
4. Consider message queuing for reliability

### For Parallel Processing
1. Use multiprocessing for CPU-bound tasks
2. Use threading for I/O-bound tasks
3. Prefer Pool for map/reduce operations
4. Use Queue for inter-process communication

## Modern Python Libraries

### Async HTTP with aiohttp
```python
import aiohttp
import asyncio

async def fetch(session, url):
    async with session.get(url) as response:
        return await response.text()

async def main():
    async with aiohttp.ClientSession() as session:
        html = await fetch(session, 'http://python.org')
        print(html)

# Run the async function
asyncio.run(main())
```

### Message Queues with Redis
```python
import redis

# Connect to Redis
r = redis.Redis(host='localhost', port=6379, db=0)

# Publish message
r.publish('channel', 'Hello, subscribers!')

# Subscribe to channel
pubsub = r.pubsub()
pubsub.subscribe('channel')

for message in pubsub.listen():
    if message['type'] == 'message':
        print(f"Received: {message['data']}")
```

## Best Practices

1. **Error Handling**: Always handle network errors and timeouts
2. **Resource Management**: Use context managers for connections
3. **Security**: Validate inputs and use secure connections
4. **Performance**: Use connection pooling and async when appropriate
</file>

<file path="Python/PARALLEL.MD">
# Python Parallel Processing Guidelines

This document outlines parallel processing techniques and best practices for Python development to improve performance and handle concurrent operations effectively.

## Concurrency vs Parallelism

### Threading (Concurrency)
- Best for I/O-bound tasks
- Limited by Global Interpreter Lock (GIL)
- Lightweight context switching

### Multiprocessing (Parallelism)
- Best for CPU-bound tasks
- True parallel execution across cores
- Higher memory overhead

### Async/Await (Concurrency)
- Best for I/O-bound tasks with many concurrent operations
- Single-threaded cooperative multitasking
- Low memory overhead

## Threading for I/O-Bound Tasks

### Basic Threading
```python
import threading
import time
import requests

def fetch_url(url):
    """Simulate I/O-bound task."""
    response = requests.get(url)
    print(f"Fetched {url}: {len(response.content)} bytes")

# Sequential execution
start_time = time.time()
urls = ["http://httpbin.org/delay/1"] * 5
for url in urls:
    fetch_url(url)
print(f"Sequential: {time.time() - start_time:.2f}s")

# Threaded execution
start_time = time.time()
threads = []
for url in urls:
    thread = threading.Thread(target=fetch_url, args=(url,))
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()
print(f"Threaded: {time.time() - start_time:.2f}s")
```

### ThreadPoolExecutor
```python
from concurrent.futures import ThreadPoolExecutor, as_completed
import requests

def fetch_url(url):
    response = requests.get(url)
    return url, len(response.content)

urls = ["http://httpbin.org/delay/1"] * 10

# Using ThreadPoolExecutor
with ThreadPoolExecutor(max_workers=5) as executor:
    # Submit all tasks
    future_to_url = {executor.submit(fetch_url, url): url for url in urls}

    # Process completed tasks
    for future in as_completed(future_to_url):
        url = future_to_url[future]
        try:
            url, size = future.result()
            print(f"{url}: {size} bytes")
        except Exception as exc:
            print(f"{url} generated an exception: {exc}")
```

### Thread Safety
```python
import threading
import time

# Thread-safe counter
class SafeCounter:
    def __init__(self):
        self._value = 0
        self._lock = threading.Lock()

    def increment(self):
        with self._lock:
            self._value += 1

    def get_value(self):
        with self._lock:
            return self._value

# Thread-local storage
thread_local_data = threading.local()

def process_data(data):
    thread_local_data.value = data
    # Each thread has its own copy of thread_local_data.value
    print(f"Thread {threading.current_thread().name}: {thread_local_data.value}")
```

## Multiprocessing for CPU-Bound Tasks

### Basic Multiprocessing
```python
import multiprocessing
import time

def cpu_intensive_task(n):
    """Simulate CPU-bound task."""
    result = sum(i * i for i in range(n))
    return result

# Sequential execution
start_time = time.time()
results = [cpu_intensive_task(1000000) for _ in range(4)]
print(f"Sequential: {time.time() - start_time:.2f}s")

# Parallel execution
if __name__ == "__main__":
    start_time = time.time()
    with multiprocessing.Pool(processes=4) as pool:
        results = pool.map(cpu_intensive_task, [1000000] * 4)
    print(f"Multiprocessing: {time.time() - start_time:.2f}s")
```

### ProcessPoolExecutor
```python
from concurrent.futures import ProcessPoolExecutor
import time

def factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n - 1)

numbers = [1000, 1001, 1002, 1003, 1004]

if __name__ == "__main__":
    # Sequential
    start_time = time.time()
    seq_results = [factorial(n) for n in numbers]
    print(f"Sequential: {time.time() - start_time:.2f}s")

    # Parallel
    start_time = time.time()
    with ProcessPoolExecutor(max_workers=4) as executor:
        par_results = list(executor.map(factorial, numbers))
    print(f"Parallel: {time.time() - start_time:.2f}s")
```

### Inter-Process Communication
```python
import multiprocessing
import time

def producer(queue):
    """Producer process."""
    for i in range(5):
        item = f"item_{i}"
        queue.put(item)
        print(f"Produced: {item}")
        time.sleep(0.5)
    queue.put(None)  # Sentinel value

def consumer(queue):
    """Consumer process."""
    while True:
        item = queue.get()
        if item is None:
            break
        print(f"Consumed: {item}")
        time.sleep(0.3)

if __name__ == "__main__":
    # Create shared queue
    queue = multiprocessing.Queue()

    # Create processes
    prod_process = multiprocessing.Process(target=producer, args=(queue,))
    cons_process = multiprocessing.Process(target=consumer, args=(queue,))

    # Start processes
    prod_process.start()
    cons_process.start()

    # Wait for completion
    prod_process.join()
    cons_process.join()
```

## Async/Await for I/O-Bound Tasks

### Basic Async Operations
```python
import asyncio
import aiohttp
import time

async def fetch_url(session, url):
    """Async fetch URL."""
    async with session.get(url) as response:
        content = await response.text()
        return url, len(content)

async def main():
    urls = ["http://httpbin.org/delay/1"] * 10

    # Sequential async (still sequential!)
    start_time = time.time()
    async with aiohttp.ClientSession() as session:
        for url in urls:
            await fetch_url(session, url)
    print(f"Sequential async: {time.time() - start_time:.2f}s")

    # Concurrent async
    start_time = time.time()
    async with aiohttp.ClientSession() as session:
        tasks = [fetch_url(session, url) for url in urls]
        results = await asyncio.gather(*tasks)
    print(f"Concurrent async: {time.time() - start_time:.2f}s")

# Run async code
asyncio.run(main())
```

### Async Producer-Consumer
```python
import asyncio
import random

async def producer(queue):
    """Async producer."""
    for i in range(5):
        item = f"item_{i}"
        await queue.put(item)
        print(f"Produced: {item}")
        await asyncio.sleep(random.uniform(0.1, 0.5))

    # Send sentinel values
    for _ in range(3):  # Number of consumers
        await queue.put(None)

async def consumer(queue, name):
    """Async consumer."""
    while True:
        item = await queue.get()
        if item is None:
            break
        print(f"Consumer {name} consumed: {item}")
        await asyncio.sleep(random.uniform(0.1, 0.3))
        queue.task_done()

async def main():
    queue = asyncio.Queue(maxsize=10)

    # Create tasks
    producers = [asyncio.create_task(producer(queue))]
    consumers = [asyncio.create_task(consumer(queue, f"C{i}")) for i in range(3)]

    # Wait for completion
    await asyncio.gather(*producers)
    await asyncio.gather(*consumers)

asyncio.run(main())
```

## Choosing the Right Approach

### Decision Matrix
| Task Type | Best Approach | Reason |
|-----------|---------------|---------|
| I/O-bound, few concurrent operations | Threading | Simple, lightweight |
| I/O-bound, many concurrent operations | Async/Await | Efficient, scalable |
| CPU-bound | Multiprocessing | True parallelism |
| Mixed I/O and CPU | Combination | Use appropriate tool for each part |

### Performance Comparison Example
```python
import time
import threading
import multiprocessing
import asyncio
import aiohttp

# I/O-bound task simulation
def io_bound_task_sync(delay):
    time.sleep(delay)
    return f"Completed after {delay}s"

async def io_bound_task_async(delay):
    await asyncio.sleep(delay)
    return f"Completed after {delay}s"

# CPU-bound task simulation
def cpu_bound_task(n):
    return sum(i * i for i in range(n))

# Benchmark different approaches
def benchmark_io_sync(tasks):
    start = time.time()
    results = [io_bound_task_sync(delay) for delay in tasks]
    return time.time() - start

def benchmark_io_threading(tasks):
    start = time.time()
    with threading.ThreadPoolExecutor() as executor:
        results = list(executor.map(io_bound_task_sync, tasks))
    return time.time() - start

async def benchmark_io_async(tasks):
    start = time.time()
    async with aiohttp.ClientSession() as session:
        coroutines = [io_bound_task_async(delay) for delay in tasks]
        results = await asyncio.gather(*coroutines)
    return time.time() - start

def benchmark_cpu_multiprocessing(tasks):
    start = time.time()
    with multiprocessing.Pool() as pool:
        results = pool.map(cpu_bound_task, tasks)
    return time.time() - start
```

## Best Practices

### 1. Resource Management
```python
# Proper resource cleanup
from concurrent.futures import ThreadPoolExecutor

def process_with_cleanup():
    executor = ThreadPoolExecutor(max_workers=4)
    try:
        # Do work
        pass
    finally:
        executor.shutdown(wait=True)

# Better: Use context manager
with ThreadPoolExecutor(max_workers=4) as executor:
    # Do work
    pass
# Executor automatically shut down
```

### 2. Error Handling
```python
from concurrent.futures import ThreadPoolExecutor, as_completed

def risky_task(task_id):
    if task_id == 3:
        raise ValueError(f"Task {task_id} failed")
    return f"Task {task_id} completed"

with ThreadPoolExecutor(max_workers=3) as executor:
    futures = {executor.submit(risky_task, i): i for i in range(5)}

    for future in as_completed(futures):
        task_id = futures[future]
        try:
            result = future.result()
            print(result)
        except Exception as exc:
            print(f"Task {task_id} generated an exception: {exc}")
```

### 3. Performance Tuning
```python
import multiprocessing
import os

# Optimal worker count
def get_optimal_workers():
    # For I/O-bound: more workers than CPUs
    # For CPU-bound: equal to number of CPUs
    cpu_count = os.cpu_count()
    return {
        'io_bound': cpu_count * 2,
        'cpu_bound': cpu_count
    }

# Monitor performance
import time
from functools import wraps

def timing_decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} took {end - start:.2f}s")
        return result
    return wrapper
```

## Common Pitfalls and Solutions

### 1. Global Interpreter Lock (GIL)
```python
# Problem: Threading doesn't help CPU-bound tasks
import threading
import time

def cpu_task():
    # This won't benefit from threading due to GIL
    result = sum(i * i for i in range(1000000))
    return result

# Solution: Use multiprocessing
import multiprocessing

if __name__ == "__main__":
    with multiprocessing.Pool() as pool:
        results = pool.map(cpu_task, range(4))
```

### 2. Race Conditions
```python
import threading

# Problem: Race condition
counter = 0

def increment():
    global counter
    for _ in range(100000):
        counter += 1  # Not atomic!

# Solution: Use locks
counter = 0
lock = threading.Lock()

def safe_increment():
    global counter
    for _ in range(100000):
        with lock:
            counter += 1
```

### 3. Deadlocks
```python
import threading

lock1 = threading.Lock()
lock2 = threading.Lock()

# Problem: Potential deadlock
def task1():
    with lock1:
        with lock2:  # May deadlock if task2 holds lock2
            pass

def task2():
    with lock2:
        with lock1:  # May deadlock if task1 holds lock1
            pass

# Solution: Consistent lock ordering
def task1_safe():
    with lock1:
        with lock2:
            pass

def task2_safe():
    with lock1:  # Same order
        with lock2:
            pass
```

## Monitoring and Debugging

### 1. Profiling Parallel Code
```python
import cProfile
import pstats
from concurrent.futures import ProcessPoolExecutor

def profile_parallel_function():
    profiler = cProfile.Profile()
    profiler.enable()

    # Your parallel code here
    with ProcessPoolExecutor() as executor:
        results = list(executor.map(some_function, data))

    profiler.disable()
    stats = pstats.Stats(profiler)
    stats.sort_stats('cumulative')
    stats.print_stats()
```

### 2. Monitoring Resource Usage
```python
import psutil
import threading
import time

def monitor_resources():
    process = psutil.Process()
    while True:
        cpu_percent = process.cpu_percent()
        memory_info = process.memory_info()
        print(f"CPU: {cpu_percent}%, Memory: {memory_info.rss / 1024 / 1024:.2f}MB")
        time.sleep(1)

# Start monitoring in background
monitor_thread = threading.Thread(target=monitor_resources, daemon=True)
monitor_thread.start()
```

## Quick Reference

| Approach | Use Case | Example |
|----------|----------|---------|
| Threading | I/O-bound, few operations | `ThreadPoolExecutor` |
| Multiprocessing | CPU-bound | `ProcessPoolExecutor` |
| Async/Await | I/O-bound, many operations | `asyncio.gather()` |
| Concurrent.futures | Simple parallelism | `submit()` and `map()` |

| Best Practice | Implementation |
|---------------|----------------|
| Resource Cleanup | Use context managers |
| Error Handling | Wrap futures in try/except |
| Performance Tuning | Profile and measure |
| Thread Safety | Use locks for shared data |
| Process Safety | Use multiprocessing primitives |
</file>

<file path="Python/PATTERNS.MD">
# Python Design Patterns

This document outlines essential design patterns commonly used in Python development.

## Behavioral Patterns

### Strategy Pattern
**When to use**: When you need to switch between different algorithms or behaviors at runtime.

```python
from abc import ABC, abstractmethod
from typing import List

# Strategy interface
class SortStrategy(ABC):
    @abstractmethod
    def sort(self, data: List[int]) -> List[int]:
        pass

# Concrete strategies
class BubbleSort(SortStrategy):
    def sort(self, data: List[int]) -> List[int]:
        # Bubble sort implementation
        result = data.copy()
        for i in range(len(result)):
            for j in range(0, len(result) - i - 1):
                if result[j] > result[j + 1]:
                    result[j], result[j + 1] = result[j + 1], result[j]
        return result

class QuickSort(SortStrategy):
    def sort(self, data: List[int]) -> List[int]:
        # Quick sort implementation
        if len(data) <= 1:
            return data
        pivot = data[len(data) // 2]
        left = [x for x in data if x < pivot]
        middle = [x for x in data if x == pivot]
        right = [x for x in data if x > pivot]
        return self.sort(left) + middle + self.sort(right)

# Context class
class Sorter:
    def __init__(self, strategy: SortStrategy):
        self._strategy = strategy

    def set_strategy(self, strategy: SortStrategy):
        self._strategy = strategy

    def sort(self, data: List[int]) -> List[int]:
        return self._strategy.sort(data)

# Usage
data = [64, 34, 25, 12, 22, 11, 90]
sorter = Sorter(BubbleSort())
result = sorter.sort(data)
```

### Observer Pattern
**When to use**: When changes in one object need to be notified to others.

```python
from abc import ABC, abstractmethod
from typing import List

# Observer interface
class Observer(ABC):
    @abstractmethod
    def update(self, message: str):
        pass

# Subject interface
class Subject(ABC):
    @abstractmethod
    def attach(self, observer: Observer):
        pass

    @abstractmethod
    def detach(self, observer: Observer):
        pass

    @abstractmethod
    def notify(self, message: str):
        pass

# Concrete Subject
class NewsAgency(Subject):
    def __init__(self):
        self._observers: List[Observer] = []
        self._news = ""

    def attach(self, observer: Observer):
        if observer not in self._observers:
            self._observers.append(observer)

    def detach(self, observer: Observer):
        self._observers.remove(observer)

    def notify(self, message: str):
        for observer in self._observers:
            observer.update(message)

    def add_news(self, news: str):
        self._news = news
        self.notify(news)

# Concrete Observer
class NewsChannel(Observer):
    def __init__(self, name: str):
        self.name = name

    def update(self, message: str):
        print(f"{self.name} received news: {message}")

# Usage
agency = NewsAgency()
channel1 = NewsChannel("CNN")
channel2 = NewsChannel("BBC")

agency.attach(channel1)
agency.attach(channel2)

agency.add_news("Breaking: Major event occurred!")
```

### Command Pattern
**When to use**: To encapsulate requests as objects, allowing parameterization of clients with queues, requests, and operations.

```python
from abc import ABC, abstractmethod

# Command interface
class Command(ABC):
    @abstractmethod
    def execute(self):
        pass

    @abstractmethod
    def undo(self):
        pass

# Receiver
class Light:
    def __init__(self):
        self._is_on = False

    def turn_on(self):
        self._is_on = True
        print("Light is ON")

    def turn_off(self):
        self._is_on = False
        print("Light is OFF")

# Concrete Commands
class TurnOnCommand(Command):
    def __init__(self, light: Light):
        self._light = light

    def execute(self):
        self._light.turn_on()

    def undo(self):
        self._light.turn_off()

class TurnOffCommand(Command):
    def __init__(self, light: Light):
        self._light = light

    def execute(self):
        self._light.turn_off()

    def undo(self):
        self._light.turn_on()

# Invoker
class RemoteControl:
    def __init__(self):
        self._history: List[Command] = []

    def submit(self, command: Command):
        command.execute()
        self._history.append(command)

    def undo_last(self):
        if self._history:
            last_command = self._history.pop()
            last_command.undo()

# Usage
light = Light()
remote = RemoteControl()

turn_on = TurnOnCommand(light)
turn_off = TurnOffCommand(light)

remote.submit(turn_on)  # Light is ON
remote.submit(turn_off)  # Light is OFF
remote.undo_last()  # Light is ON
```

## Structural Patterns

### Decorator Pattern
**When to use**: To add new functionality to objects dynamically without affecting other objects.

```python
from functools import wraps

# Function decorator
def timing_decorator(func):
    import time
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} took {end_time - start_time:.4f} seconds")
        return result
    return wrapper

@timing_decorator
def slow_function():
    import time
    time.sleep(1)
    return "Done"

# Class decorator
def singleton(cls):
    instances = {}
    @wraps(cls)
    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return get_instance

@singleton
class DatabaseConnection:
    def __init__(self):
        print("Creating database connection")

# Usage
slow_function()  # Will print execution time

db1 = DatabaseConnection()  # Creates new instance
db2 = DatabaseConnection()  # Returns same instance
print(db1 is db2)  # True
```

### Adapter Pattern
**When to use**: To make incompatible interfaces work together.

```python
from typing import Protocol

# Target interface
class PaymentProcessor(Protocol):
    def pay(self, amount: float) -> bool:
        pass

# Adaptee classes
class Stripe:
    def make_payment(self, cents: int) -> dict:
        # Stripe payment logic
        return {"success": True, "transaction_id": "stripe_123"}

class PayPal:
    def send_money(self, dollars: float, currency: str = "USD") -> str:
        # PayPal payment logic
        if currency == "USD":
            return "paypal_success_456"
        return "paypal_failed"

# Adapter classes
class StripeAdapter(PaymentProcessor):
    def __init__(self, stripe: Stripe):
        self._stripe = stripe

    def pay(self, amount: float) -> bool:
        result = self._stripe.make_payment(int(amount * 100))  # Convert to cents
        return result["success"]

class PayPalAdapter(PaymentProcessor):
    def __init__(self, paypal: PayPal):
        self._paypal = paypal

    def pay(self, amount: float) -> bool:
        transaction_id = self._paypal.send_money(amount)
        return transaction_id.startswith("paypal_success")

# Client code
def process_payment(processor: PaymentProcessor, amount: float):
    if processor.pay(amount):
        print(f"Payment of ${amount} processed successfully")
    else:
        print("Payment failed")

# Usage
stripe_adapter = StripeAdapter(Stripe())
paypal_adapter = PayPalAdapter(PayPal())

process_payment(stripe_adapter, 100.0)
process_payment(paypal_adapter, 100.0)
```

## Creational Patterns

### Factory Pattern
**When to use**: When object creation logic is complex or varies based on conditions.

```python
from enum import Enum
from typing import Dict, Type

class DatabaseType(Enum):
    MYSQL = "mysql"
    POSTGRES = "postgres"
    SQLITE = "sqlite"

# Product interface
class DatabaseConnection:
    def connect(self):
        pass

    def execute_query(self, query: str):
        pass

# Concrete products
class MySQLConnection(DatabaseConnection):
    def connect(self):
        print("Connecting to MySQL database")

    def execute_query(self, query: str):
        print(f"Executing MySQL query: {query}")

class PostgreSQLConnection(DatabaseConnection):
    def connect(self):
        print("Connecting to PostgreSQL database")

    def execute_query(self, query: str):
        print(f"Executing PostgreSQL query: {query}")

class SQLiteConnection(DatabaseConnection):
    def connect(self):
        print("Connecting to SQLite database")

    def execute_query(self, query: str):
        print(f"Executing SQLite query: {query}")

# Factory
class DatabaseFactory:
    _connections: Dict[DatabaseType, Type[DatabaseConnection]] = {
        DatabaseType.MYSQL: MySQLConnection,
        DatabaseType.POSTGRES: PostgreSQLConnection,
        DatabaseType.SQLITE: SQLiteConnection,
    }

    @classmethod
    def create_connection(cls, db_type: DatabaseType) -> DatabaseConnection:
        connection_class = cls._connections.get(db_type)
        if not connection_class:
            raise ValueError(f"Unsupported database type: {db_type}")
        return connection_class()

# Usage
mysql_conn = DatabaseFactory.create_connection(DatabaseType.MYSQL)
mysql_conn.connect()

postgres_conn = DatabaseFactory.create_connection(DatabaseType.POSTGRES)
postgres_conn.connect()
```

### Builder Pattern
**When to use**: To construct complex objects step by step.

```python
from typing import List, Optional

class Computer:
    def __init__(self):
        self.cpu = ""
        self.ram = ""
        self.storage = ""
        self.gpu = ""
        self.os = ""

    def __str__(self):
        return f"Computer(CPU: {self.cpu}, RAM: {self.ram}, Storage: {self.storage}, GPU: {self.gpu}, OS: {self.os})"

class ComputerBuilder:
    def __init__(self):
        self._computer = Computer()

    def set_cpu(self, cpu: str) -> 'ComputerBuilder':
        self._computer.cpu = cpu
        return self

    def set_ram(self, ram: str) -> 'ComputerBuilder':
        self._computer.ram = ram
        return self

    def set_storage(self, storage: str) -> 'ComputerBuilder':
        self._computer.storage = storage
        return self

    def set_gpu(self, gpu: str) -> 'ComputerBuilder':
        self._computer.gpu = gpu
        return self

    def set_os(self, os: str) -> 'ComputerBuilder':
        self._computer.os = os
        return self

    def build(self) -> Computer:
        return self._computer

# Director
class ComputerDirector:
    @staticmethod
    def build_gaming_computer(builder: ComputerBuilder) -> Computer:
        return (builder
                .set_cpu("Intel i9")
                .set_ram("32GB DDR4")
                .set_storage("1TB NVMe SSD")
                .set_gpu("RTX 4090")
                .set_os("Windows 11")
                .build())

    @staticmethod
    def build_office_computer(builder: ComputerBuilder) -> Computer:
        return (builder
                .set_cpu("Intel i5")
                .set_ram("16GB DDR4")
                .set_storage("512GB SSD")
                .set_os("Ubuntu 22.04")
                .build())

# Usage
builder = ComputerBuilder()
gaming_pc = ComputerDirector.build_gaming_computer(builder)
print(gaming_pc)

office_builder = ComputerBuilder()
office_pc = ComputerDirector.build_office_computer(office_builder)
print(office_pc)
```

## Python-Specific Patterns

### Context Manager Pattern
**When to use**: For resource management and setup/teardown operations.

```python
from contextlib import contextmanager
import sqlite3

# Class-based context manager
class DatabaseManager:
    def __init__(self, db_name: str):
        self.db_name = db_name
        self.connection = None

    def __enter__(self):
        self.connection = sqlite3.connect(self.db_name)
        return self.connection

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.connection:
            self.connection.close()

# Function-based context manager
@contextmanager
def temporary_directory():
    import tempfile
    import shutil
    temp_dir = tempfile.mkdtemp()
    try:
        yield temp_dir
    finally:
        shutil.rmtree(temp_dir)

# Usage
with DatabaseManager("example.db") as conn:
    cursor = conn.cursor()
    cursor.execute("CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT)")

with temporary_directory() as temp_dir:
    print(f"Temporary directory: {temp_dir}")
    # Directory is automatically cleaned up
```

## Anti-Patterns to Avoid

### God Object Pattern
```python
# Bad: One class doing everything
class GodObject:
    def handle_user_auth(self): pass
    def process_payments(self): pass
    def manage_inventory(self): pass
    def send_emails(self): pass
    def generate_reports(self): pass

# Good: Separate classes with single responsibilities
class UserAuthenticator: pass
class PaymentProcessor: pass
class InventoryManager: pass
class EmailService: pass
class ReportGenerator: pass
```

## Quick Reference

| Pattern | Problem It Solves | When to Use |
|---------|------------------|-------------|
| Strategy | Switching algorithms | Multiple approaches for same task |
| Observer | Notification system | One-to-many dependencies |
| Command | Encapsulating requests | Undo/redo, queuing |
| Decorator | Adding functionality | Dynamic behavior extension |
| Adapter | Interface compatibility | Integrating incompatible systems |
| Factory | Object creation | Complex instantiation logic |
| Builder | Complex object construction | Step-by-step object creation |

| Python-Specific | Use Case |
|-----------------|----------|
| @property | Computed attributes |
| @classmethod/@staticmethod | Class/utility methods |
| Context managers | Resource management |
| Decorators | Cross-cutting concerns |
| Dataclasses | Simple data containers |
</file>

<file path="Python/README.md">
# Python Development Guidelines

## Overview

Essential guidelines and patterns for Python development.

## Contents

- **IPC.MD**: Inter-process communication methods for Python applications
- **Other guides**: Clean code, testing, static analysis, and concurrency

## Getting Started

1. Use appropriate libraries for your communication needs
2. Follow Python best practices (PEP 8)
3. Leverage Python's rich ecosystem of packages

## Key Principles

- Use requests for HTTP communication
- Apply async/await for I/O-bound operations
- Use multiprocessing for CPU-intensive tasks
- Follow Python idioms and conventions
- Write readable, maintainable code
</file>

<file path="Python/STATICANALYSIS.MD">
# Python Static Analysis Guidelines

This document outlines static analysis tools and practices for Python development to ensure code quality, security, and maintainability.

## Essential Static Analysis Tools

### 1. Linters

#### Flake8
Flake8 combines multiple tools to check style and complexity.

**Installation:**
```bash
pip install flake8
```

**Configuration (.flake8):**
```ini
[flake8]
max-line-length = 88
extend-ignore = E203, W503
exclude =
    .git,
    __pycache__,
    .venv,
    migrations
max-complexity = 10
```

#### Pylint
Pylint is a comprehensive linter with extensive checking capabilities.

**Installation:**
```bash
pip install pylint
```

**Configuration (.pylintrc):**
```ini
[MASTER]
ignore-patterns = test_.*,conftest.py

[MESSAGES CONTROL]
disable =
    missing-docstring,
    too-few-public-methods,
    too-many-arguments,
    too-many-locals

[FORMAT]
max-line-length = 88
```

### 2. Formatters

#### Black
Black is an uncompromising code formatter.

**Installation:**
```bash
pip install black
```

**Usage:**
```bash
black .  # Format entire project
black src/module.py  # Format specific file
```

**Configuration (pyproject.toml):**
```toml
[tool.black]
line-length = 88
target-version = ['py38']
include = '\.pyi?$'
extend-exclude = '''
/(
  # directories
  migrations
  | \.git
  | \.venv
)/
'''
```

#### Isort
Isort sorts and organizes import statements.

**Installation:**
```bash
pip install isort
```

**Configuration (.isort.cfg):**
```ini
[settings]
profile = black
multi_line_output = 3
line_length = 88
known_first_party = myproject
known_third_party = django,requests,setuptools
```

### 3. Type Checkers

#### MyPy
MyPy performs static type checking for Python.

**Installation:**
```bash
pip install mypy
```

**Configuration (mypy.ini):**
```ini
[mypy]
python_version = 3.8
warn_return_any = True
warn_unused_configs = True
disallow_untyped_defs = True
disallow_incomplete_defs = True
check_untyped_defs = True
disallow_untyped_decorators = True

[mypy-tests.*]
disallow_untyped_defs = False
```

#### Pyright
Pyright is Microsoft's fast type checker.

**Installation:**
```bash
npm install -g pyright
# or
pip install pyright
```

**Configuration (pyrightconfig.json):**
```json
{
    "include": [
        "src"
    ],
    "exclude": [
        "**/node_modules",
        "**/__pycache__"
    ],
    "pythonVersion": "3.8",
    "typeCheckingMode": "basic"
}
```

## Security Analysis Tools

### Bandit
Bandit finds common security issues in Python code.

**Installation:**
```bash
pip install bandit
```

**Usage:**
```bash
bandit -r .  # Scan entire project
bandit src/module.py  # Scan specific file
```

**Configuration (.bandit):**
```ini
[bandit]
exclude_dirs: /test/,/migrations/
skips: B101,B102
```

### Safety
Safety checks dependencies for known security vulnerabilities.

**Installation:**
```bash
pip install safety
```

**Usage:**
```bash
safety check  # Check current environment
safety check -r requirements.txt  # Check requirements file
```

## Code Quality Metrics

### Radon
Radon computes various code metrics.

**Installation:**
```bash
pip install radon
```

**Usage:**
```bash
radon cc .  # Cyclomatic complexity
radon mi .  # Maintainability index
radon raw .  # Raw metrics
```

### Vulture
Vulture finds dead code in Python programs.

**Installation:**
```bash
pip install vulture
```

**Usage:**
```bash
vulture .  # Find unused code
vulture . --min-confidence 80  # Higher confidence threshold
```

## Integrated Analysis Tools

### Pre-commit
Pre-commit manages and maintains multi-language pre-commit hooks.

**Installation:**
```bash
pip install pre-commit
```

**Configuration (.pre-commit-config.yaml):**
```yaml
repos:
  - repo: https://github.com/psf/black
    rev: 22.3.0
    hooks:
      - id: black

  - repo: https://github.com/pycqa/isort
    rev: 5.10.1
    hooks:
      - id: isort

  - repo: https://github.com/pycqa/flake8
    rev: 4.0.1
    hooks:
      - id: flake8

  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v0.950
    hooks:
      - id: mypy
```

### Prospector
Prospector combines multiple tools into a single command.

**Installation:**
```bash
pip install prospector
```

**Configuration (.prospector.yaml):**
```yaml
strictness: medium
doc-warnings: false
test-warnings: false
member-warnings: false

pyflakes:
  run: true

pylint:
  run: true
  options:
    disable:
      - missing-docstring
      - too-few-public-methods

mypy:
  run: true
```

## CI/CD Integration

### GitHub Actions Example
```yaml
name: Code Quality
on: [push, pull_request]
jobs:
  static-analysis:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: 3.8
    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
    - name: Run Black
      run: black --check .
    - name: Run isort
      run: isort --check-only .
    - name: Run Flake8
      run: flake8 .
    - name: Run MyPy
      run: mypy .
    - name: Run Bandit
      run: bandit -r .
    - name: Run Safety
      run: safety check
```

### GitLab CI Example
```yaml
stages:
  - test
  - quality

static_analysis:
  stage: quality
  image: python:3.8
  before_script:
    - pip install -r requirements.txt
    - pip install -r requirements-dev.txt
  script:
    - black --check .
    - isort --check-only .
    - flake8 .
    - mypy .
    - bandit -r .
  only:
    - merge_requests
```

## Editor Integration

### VS Code Settings
```json
{
    "python.linting.enabled": true,
    "python.linting.flake8Enabled": true,
    "python.formatting.provider": "black",
    "python.formatting.blackArgs": ["--line-length", "88"],
    "editor.formatOnSave": true,
    "[python]": {
        "editor.codeActionsOnSave": {
            "source.organizeImports": true
        }
    }
}
```

### Vim/Neovim with ALE
```vim
let g:ale_linters = {
\   'python': ['flake8', 'mypy', 'bandit'],
\}
let g:ale_fixers = {
\   'python': ['black', 'isort'],
\}
let g:ale_fix_on_save = 1
```

## Best Practices

### 1. Tool Selection
Choose tools based on your needs:
- **Minimal setup**: Start with Black + Flake8
- **Comprehensive**: Add MyPy, Bandit, and Radon
- **Enterprise**: Include all tools with strict configurations

### 2. Configuration Management
- Keep configurations in version control
- Use standard configuration file names
- Document custom rules and exceptions

### 3. Gradual Adoption
```bash
# 1. Format existing code
black .

# 2. Sort imports
isort .

# 3. Fix obvious issues
autoflake --remove-all-unused-imports --recursive --remove-unused-variables --in-place .

# 4. Run linters and fix issues incrementally
```

### 4. False Positive Management
- Use inline comments to disable specific warnings:
  ```python
  x = 1  # noqa: E225
  ```
- Configure tool exclusions for legitimate cases
- Regular review of suppressed warnings

## Quality Gates

### Merge Requirements
- All linters must pass without errors
- Type checker must pass with no errors
- Security scanner must find no high-severity issues
- Code coverage must not decrease

### Thresholds
| Metric | Target |
|--------|--------|
| Cyclomatic Complexity | < 10 per function |
| Maintainability Index | > 20 |
| Code Coverage | > 80% |
| Security Issues | 0 high/critical |

## Troubleshooting Common Issues

### MyPy Import Errors
```ini
[mypy]
mypy_path = src
explicit_package_bases = True
```

### Black/Isort Conflicts
```toml
[tool.isort]
profile = "black"
```

### Large Project Performance
- Use exclude patterns in configurations
- Run tools on changed files only in CI
- Consider incremental analysis tools

## Quick Reference

| Tool | Purpose | Command |
|------|---------|---------|
| Black | Code formatting | `black .` |
| Isort | Import sorting | `isort .` |
| Flake8 | Style checking | `flake8 .` |
| MyPy | Type checking | `mypy .` |
| Bandit | Security scanning | `bandit -r .` |
| Safety | Dependency checking | `safety check` |

| Integration | Setup |
|------------|-------|
| Pre-commit | `pre-commit install` |
| CI/CD | Add tool commands to pipeline |
| Editors | Configure language server and linters |
</file>

<file path="Python/TESTING.MD">
# Python Testing Guidelines

This document outlines testing principles and practices specifically for Python development, building upon the general principles in `/TESTING.MD`.

## Test Structure and Organization

### Project Layout
```
project/
 src/
    mypackage/
 tests/
    unit/
       test_models.py
       test_utils.py
    integration/
       test_api.py
    conftest.py
 pytest.ini
 requirements-test.txt
```

### Test File Naming
- Test files: `test_*.py` or `*_test.py`
- Test functions: `test_*`
- Test classes: `Test*`

## Pytest Best Practices

### Basic Test Structure
```python
import pytest
from mypackage.module import MyClass

def test_basic_functionality():
    """Test basic functionality of MyClass."""
    obj = MyClass()
    result = obj.some_method()
    assert result == expected_value

def test_edge_case():
    """Test edge case handling."""
    obj = MyClass()
    with pytest.raises(ValueError):
        obj.some_method(invalid_input)
```

### Fixtures for Test Setup
```python
import pytest
from unittest.mock import Mock

@pytest.fixture
def mock_database():
    """Create a mock database connection."""
    return Mock()

@pytest.fixture
def sample_data():
    """Provide sample test data."""
    return {
        'users': [
            {'id': 1, 'name': 'Alice'},
            {'id': 2, 'name': 'Bob'}
        ]
    }

def test_user_processing(mock_database, sample_data):
    """Test user processing with fixtures."""
    # Test implementation using fixtures
    pass
```

### Parametrized Tests
```python
import pytest

@pytest.mark.parametrize("input_value,expected", [
    (0, 0),
    (1, 1),
    (10, 55),
    (-1, ValueError),
])
def test_fibonacci(input_value, expected):
    """Test fibonacci function with various inputs."""
    if expected == ValueError:
        with pytest.raises(ValueError):
            fibonacci(input_value)
    else:
        assert fibonacci(input_value) == expected
```

## Test Categories

### Unit Tests
Focus on testing individual functions and methods in isolation.

```python
def test_calculate_tax():
    """Unit test for tax calculation."""
    result = calculate_tax(100.0, 0.1)
    assert result == 10.0

def test_user_validation():
    """Unit test for user input validation."""
    user = User(email="invalid-email")
    with pytest.raises(ValidationError):
        user.validate()
```

### Integration Tests
Test interactions between components and external systems.

```python
def test_database_integration(database_connection):
    """Integration test with database."""
    user_repo = UserRepository(database_connection)
    user = User(name="Test User", email="test@example.com")

    # Test create
    created_user = user_repo.create(user)
    assert created_user.id is not None

    # Test retrieve
    retrieved_user = user_repo.get(created_user.id)
    assert retrieved_user.name == user.name
```

### End-to-End Tests
Test complete user workflows and system behavior.

```python
def test_user_registration_flow(client):
    """E2E test for user registration."""
    # Navigate to registration page
    response = client.get('/register')
    assert response.status_code == 200

    # Submit registration form
    response = client.post('/register', data={
        'username': 'testuser',
        'email': 'test@example.com',
        'password': 'securepassword'
    })

    # Verify redirect to dashboard
    assert response.status_code == 302
    assert response.location == '/dashboard'
```

## Mocking and Stubbing

### Mocking External Dependencies
```python
from unittest.mock import Mock, patch

@patch('mypackage.external_api.call_external_service')
def test_with_mocked_api(mock_api):
    """Test with mocked external API."""
    mock_api.return_value = {'status': 'success'}

    result = my_function_that_calls_api()
    assert result == 'processed'
    mock_api.assert_called_once_with(expected_params)

def test_with_manual_mock():
    """Test with manually created mock."""
    mock_service = Mock()
    mock_service.get_user.return_value = User(id=1, name='Test')

    processor = UserProcessor(mock_service)
    result = processor.process_user(1)

    assert result.name == 'Test'
    mock_service.get_user.assert_called_once_with(1)
```

### Mocking Context Managers
```python
from unittest.mock import mock_open, patch

def test_file_processing():
    """Test file processing with mocked file operations."""
    mock_file_content = "line1\nline2\nline3"

    with patch('builtins.open', mock_open(read_data=mock_file_content)):
        result = process_file('fake_file.txt')
        assert len(result) == 3
```

## Test Configuration

### pytest.ini
```ini
[tool:pytest]
testpaths = tests
python_files = test_*.py *_test.py
python_classes = Test*
python_functions = test_*
addopts =
    --verbose
    --tb=short
    --strict-markers
markers =
    slow: marks tests as slow
    integration: marks tests as integration tests
    e2e: marks tests as end-to-end tests
```

### Test Requirements
```txt
pytest>=6.0.0
pytest-cov>=2.10.0
pytest-mock>=3.3.0
responses>=0.12.0
freezegun>=1.0.0
```

## Test Quality Standards

### Test Independence
```python
# Good: Independent tests
def test_user_creation():
    user = create_user(name="Alice")
    assert user.name == "Alice"

def test_user_deletion():
    user = create_user(name="Bob")
    delete_user(user.id)
    assert get_user(user.id) is None
```

### Test Length Constraints

Unit tests must be concise and focused:

*   **Maximum Length:** Unit tests should not exceed 10 lines of code (LOC).
*   **Extended Length:** Unit tests may extend to up to 20 LOC, but this requires a comment explaining why the test cannot be simplified while maintaining adequate coverage.
*   **Rationale:** Short tests are easier to understand, maintain, and debug. They also tend to be more focused on specific behaviors.

For tests exceeding 10 LOC, include a comment in this format:
```python
# Extended test: [Reason why this test cannot be simplified while maintaining adequate coverage]
def test_complex_scenario():
    # Test implementation that requires more lines
    pass
```

### Clear Assertions
```python
# Good: Specific assertions
def test_calculation():
    result = calculate_discount(100, 0.1)
    assert result == 90.0
    assert isinstance(result, float)

# Avoid: Generic assertions
def test_calculation_bad():
    result = calculate_discount(100, 0.1)
    assert result  # Too vague
```

### Proper Test Data
```python
# Good: Realistic test data
def test_email_validation():
    valid_emails = [
        "user@example.com",
        "test.user@domain.co.uk",
        "user+tag@site.org"
    ]

    for email in valid_emails:
        assert is_valid_email(email)
```

## Coverage and Quality Metrics

### Coverage Requirements
- **Line Coverage**: Minimum 80%
- **Branch Coverage**: Minimum 70%
- **Critical Path Coverage**: 100% for business logic

### Running Tests with Coverage
```bash
# Run tests with coverage
pytest --cov=mypackage --cov-report=html --cov-report=term

# Run tests with coverage thresholds
pytest --cov=mypackage --cov-fail-under=80
```

## Test Timeouts

### Timeout Standards
- **Unit Tests**: Maximum 1 second per test
- **Integration Tests**: Maximum 5 seconds per test
- **End-to-End Tests**: Maximum 30 seconds per test

### Implementing Timeouts
```python
import pytest

@pytest.mark.timeout(1)
def test_fast_unit_test():
    """Fast unit test with 1-second timeout."""
    result = quick_calculation()
    assert result == expected

@pytest.mark.timeout(5)
def test_integration_test():
    """Integration test with 5-second timeout."""
    result = complex_operation()
    assert result is not None
```

## Continuous Integration

### CI Pipeline Configuration
```yaml
# .github/workflows/test.yml
name: Tests
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [3.8, 3.9, 3.10]
    steps:
    - uses: actions/checkout@v2
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: ${{ matrix.python-version }}
    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        pip install -r requirements-test.txt
    - name: Run tests
      run: |
        pytest --cov=mypackage --cov-report=xml
    - name: Upload coverage
      uses: codecov/codecov-action@v1
```

## Quick Reference

| Test Type | Scope | Speed | Coverage Target |
|-----------|-------|-------|-----------------|
| Unit | Individual functions/methods | Fast (<1s) | 80%+ |
| Integration | Component interactions | Medium (<5s) | 70%+ |
| E2E | Complete workflows | Slow (<30s) | Critical paths |

| Best Practice | Implementation |
|---------------|----------------|
| Test Independence | Each test sets up its own data |
| Clear Naming | `test_what_is_being_tested_expected_behavior` |
| Specific Assertions | Assert exact expected values |
| Mock External Dependencies | Use unittest.mock for isolation |
| Measure Coverage | Run with pytest-cov regularly |
</file>

<file path="React/CLEANCODE.MD">
# React/JavaScript Clean Code Guidelines

This document outlines React and JavaScript-specific clean code principles that build upon the general clean code principles.

## Naming Conventions

### Components
- Use PascalCase for component names: `UserProfile`, `NavigationMenu`
- Use camelCase for prop names: `userName`, `isLoading`
- File names should match component names: `UserProfile.jsx`, `NavigationMenu.js`

### Functions and Variables
- Use camelCase for functions and variables: `calculateTotal()`, `userName`
- Use descriptive names that explain what the function does or variable represents
- Boolean props should start with `is`, `has`, or `should`: `isLoading`, `hasError`, `shouldRefresh`

### Constants
- Use UPPER_SNAKE_CASE for global constants: `MAX_RETRY_ATTEMPTS`, `API_BASE_URL`
- Use camelCase for local constants: `defaultConfig`, `initialState`

## React-Specific Best Practices

### Component Structure
- Prefer functional components with hooks over class components
- Keep components small and focused on a single responsibility
- Extract custom hooks for reusable stateful logic
- Use fragments (`<>...</>`) instead of unnecessary div wrappers

### Props and State
- Destructure props at the beginning of functional components:
  ```javascript
  function UserCard({ name, email, avatar }) {
    // component logic
  }
  ```
- Use PropTypes or TypeScript for prop validation
- Keep state as local as possible to where it's used
- Lift state up only when necessary for sharing between components

### Hooks
- Follow the Rules of Hooks (only call hooks at the top level, only call hooks from React functions)
- Use `useState` for simple state management
- Use `useEffect` for side effects, specifying dependency arrays appropriately
- Use `useCallback` and `useMemo` for performance optimization when needed

### Event Handlers
- Define event handlers inside components using useCallback for performance:
  ```javascript
  const handleClick = useCallback(() => {
    // handle click
  }, [dependencies]);
  ```
- Name event handlers with `handle` prefix: `handleClick`, `handleSubmit`

## JavaScript-Specific Best Practices

### ES6+ Features
- Use arrow functions for anonymous functions and callbacks
- Use destructuring for objects and arrays:
  ```javascript
  const { name, age } = user;
  const [first, second] = items;
  ```
- Use template literals for string interpolation:
  ```javascript
  const message = `Hello ${name}, you have ${count} messages`;
  ```

### Imports and Exports
- Use ES6 import/export syntax
- Group imports in order:
  1. External libraries
  2. Internal modules
  3. Components
  4. Assets
- Use absolute imports when appropriate with path mapping

### Error Handling
- Use try/catch for async operations and error-prone code
- Handle promise rejections properly
- Use Error Boundaries for catching JavaScript errors in React components

## Performance Considerations

### Rendering Optimization
- Use React.memo for functional components that render frequently
- Use useMemo for expensive calculations:
  ```javascript
  const expensiveValue = useMemo(() => calculateExpensiveValue(a, b), [a, b]);
  ```
- Use useCallback for functions passed as props to prevent unnecessary re-renders

### Bundle Size
- Lazy load components that aren't immediately needed:
  ```javascript
  const LazyComponent = lazy(() => import('./LazyComponent'));
  ```
- Code-split by routes or features
- Tree-shake unused dependencies

### Data Fetching
- Use libraries like React Query or SWR for data fetching and caching
- Implement proper loading and error states
- Cancel requests when components unmount

## Testing Considerations

### Component Testing
- Use React Testing Library for testing user interactions and behavior
- Test components based on how users interact with them, not implementation details
- Mock external dependencies like API calls
- Test both happy paths and error conditions

### Hook Testing
- Test custom hooks separately using libraries like react-hooks-testing-library
- Test hook behavior with different inputs and edge cases
- Ensure hooks clean up properly when needed

### Integration Testing
- Test component compositions and data flow
- Use mock service workers (MSW) for API mocking in integration tests
- Test user workflows across multiple components

## Styling Best Practices

### CSS and Styling
- Use CSS modules or styled-components for component-scoped styles
- Prefer utility-first CSS frameworks like Tailwind CSS when appropriate
- Avoid inline styles for complex styling
- Use CSS variables for themeable values

### Responsive Design
- Use CSS media queries for responsive layouts
- Prefer mobile-first approach
- Test components across different screen sizes

## State Management

### Local State
- Use useState and useReducer for local component state
- Keep state flat when possible to simplify updates
- Derive computed values instead of storing them in state

### Global State
- Use Context API for simple global state needs
- Consider Redux, Zustand, or Jotai for complex state management
- Normalize state shape to avoid duplication
</file>

<file path="React/COORDINATION.MD">
# React Development - Human-Centered Workflow

## Key Principle

Focus on effective frontend team collaboration rather than complex agent coordination.

## Simple Workflow Approach

### 1. Feature Planning
- Define user stories and acceptance criteria
- Break down features into component-level tasks
- Estimate development effort and testing needs

### 2. Component Design
- Sketch component hierarchy and data flow
- Define component interfaces and props
- Plan state management approach

### 3. Implementation
- Follow React best practices and coding standards
- Use pair programming for complex components
- Conduct regular check-ins on progress

### 4. Review & Testing
- Perform code reviews with constructive feedback
- Test components in isolation and integration
- Ensure responsive design and accessibility

## Communication Guidelines

### Daily Standups
- What did you work on yesterday?
- What are you working on today?
- Any blockers or impediments?

### Component Handoffs
- Document component APIs and usage examples
- Ensure clear understanding of design requirements
- Provide access to design assets and specifications

### Problem Resolution
- Address issues early before they become blockers
- Involve designers and UX experts when needed
- Document solutions for future reference

## Tools & Practices

### Recommended Tools
- **Project Management**: Jira, Trello, or Linear
- **Version Control**: Git with feature branches
- **CI/CD**: GitHub Actions, CircleCI, or Vercel
- **Design Collaboration**: Figma, Zeplin, or Adobe XD
- **Communication**: Slack, Discord, or Teams

### Best Practices
- Keep components small and focused
- Use TypeScript for better code quality
- Write automated tests for critical components
- Maintain a consistent design system
- Regular retrospectives to improve processes

## When to Add Complexity

Only consider more complex coordination systems when:
- Team grows beyond 6-8 frontend developers
- Multiple distributed teams are involved
- Current simple approach is proven inadequate

For most teams, this human-centered approach will be more effective than complex agent orchestration.
</file>

<file path="React/IPC.MD">
# React Inter-Process Communication - Essentials

## Key Principle

Keep data fetching separate from UI components and manage state effectively.

## Common Communication Methods

### HTTP/REST with Fetch or Axios
**Best for**: Standard API calls, CRUD operations

```javascript
import axios from 'axios';

// Custom hook for data fetching
function useApi(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await axios.get(url);
        setData(response.data);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]);

  return { data, loading, error };
}

// Using the hook in a component
const UserList = () => {
  const { data: users, loading, error } = useApi('/api/users');

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
};
```

### WebSockets for Real-time Communication
**Best for**: Chat applications, live updates, notifications

```javascript
import { useState, useEffect } from 'react';

function useWebSocket(url) {
  const [ws, setWs] = useState(null);
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    const websocket = new WebSocket(url);

    websocket.onmessage = (event) => {
      const message = JSON.parse(event.data);
      setMessages(prev => [...prev, message]);
    };

    setWs(websocket);

    return () => {
      websocket.close();
    };
  }, [url]);

  const sendMessage = (message) => {
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(message));
    }
  };

  return { messages, sendMessage };
}
```

### Context for State Management
**Best for**: Sharing data across multiple components

```javascript
import React, { createContext, useContext, useState } from 'react';

const ApiContext = createContext();

export const ApiProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [notifications, setNotifications] = useState([]);

  const login = async (credentials) => {
    // Login logic
    setUser(userData);
  };

  const logout = () => {
    setUser(null);
  };

  return (
    <ApiContext.Provider value={{ user, notifications, login, logout }}>
      {children}
    </ApiContext.Provider>
  );
};

export const useApi = () => {
  const context = useContext(ApiContext);
  if (!context) {
    throw new Error('useApi must be used within ApiProvider');
  }
  return context;
};
```

## Quick Reference

| Method | Use Case | Complexity |
|--------|----------|------------|
| Fetch/Axios | API calls | Low |
| WebSockets | Real-time | Medium |
| Context | State sharing | Low |
| Redux/Zustand | Complex state | Medium |

## Implementation Guidelines

### For Data Fetching
1. Use custom hooks to encapsulate data fetching logic
2. Handle loading and error states
3. Implement caching when appropriate
4. Cancel requests when components unmount

### For Real-time Features
1. Handle connection lifecycle (open, close, error)
2. Implement reconnection logic
3. Manage message queuing during disconnects
4. Clean up connections on component unmount

### For State Management
1. Keep state as local as possible
2. Lift state up only when necessary
3. Use Context for moderate complexity
4. Consider Redux-like libraries for complex applications

## Best Practices

1. **Separation of Concerns**: Keep data fetching separate from UI
2. **Error Boundaries**: Handle network errors gracefully
3. **Performance**: Implement caching and request deduplication
4. **Security**: Validate and sanitize all data from APIs
</file>

<file path="React/PARALLEL.MD">
# React Parallel Programming Guidelines

React applications can leverage parallelism through Web Workers, concurrent rendering, and asynchronous patterns.

## Concurrent Rendering (React 18+)

### Automatic Batching
```javascript
// React 18 batches multiple state updates automatically
function handleClick() {
    setCount(c => c + 1);
    setFlag(f => !f);
    // React will re-render once at the end (batched)
}
```

### Transitions for Non-Urgent Updates
```javascript
import { startTransition } from 'react';

function TabContainer() {
    const [isPending, startTransition] = useTransition();

    function selectTab(tabId) {
        startTransition(() => {
            setTabId(tabId); // Non-urgent update
        });
    }

    return (
        <div>
            {isPending && <Spinner />}
            <Tabs onTabSelect={selectTab} />
        </div>
    );
}
```

### Suspense for Data Fetching
```javascript
// Components can suspend while loading data
<Suspense fallback={<Spinner />}>
    <UserProfile userId={userId} />
</Suspense>

// Concurrent rendering enables smooth transitions
<Profiler id="navigation" onRender={onRenderCallback}>
    <Suspense fallback={<PageSkeleton />}>
        <MainContent />
    </Suspense>
</Profiler>
```

## Web Workers for CPU-Intensive Tasks

### Worker Creation
```javascript
// heavy-computation-worker.js
self.onmessage = function(e) {
    const { data } = e;
    const result = performHeavyComputation(data);
    self.postMessage({ result });
};

// In React component
const [result, setResult] = useState(null);
const [loading, setLoading] = useState(false);

useEffect(() => {
    const worker = new Worker('/heavy-computation-worker.js');

    worker.onmessage = function(e) {
        setResult(e.data.result);
        setLoading(false);
    };

    return () => worker.terminate();
}, []);

const startComputation = (data) => {
    setLoading(true);
    worker.postMessage({ data });
};
```

### Comlink for Simplified Worker Communication
```javascript
// worker.js
import { expose } from 'comlink';

const api = {
    async processData(data) {
        // Heavy computation
        return processedData;
    }
};

expose(api);

// React component
import { wrap } from 'comlink';

function DataProcessor() {
    const [workerApi, setWorkerApi] = useState(null);

    useEffect(() => {
        const worker = new Worker('/worker.js');
        const api = wrap(worker);
        setWorkerApi(api);

        return () => worker.terminate();
    }, []);

    const process = async (data) => {
        if (workerApi) {
            const result = await workerApi.processData(data);
            return result;
        }
    };
}
```

## Asynchronous Patterns

### useEffect with Cleanup
```javascript
function DataFetcher({ userId }) {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(false);

    useEffect(() => {
        let cancelled = false;

        const fetchData = async () => {
            setLoading(true);
            try {
                const result = await fetchUserData(userId);
                if (!cancelled) {
                    setData(result);
                }
            } finally {
                if (!cancelled) {
                    setLoading(false);
                }
            }
        };

        fetchData();

        return () => {
            cancelled = true;
        };
    }, [userId]);

    return loading ? <Spinner /> : <DataView data={data} />;
}
```

### AbortController for Request Cancellation
```javascript
function ApiComponent({ query }) {
    const [data, setData] = useState(null);

    useEffect(() => {
        const controller = new AbortController();

        const fetchData = async () => {
            try {
                const response = await fetch(`/api/search?q=${query}`, {
                    signal: controller.signal
                });
                const result = await response.json();
                setData(result);
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Fetch error:', error);
                }
            }
        };

        fetchData();

        return () => {
            controller.abort();
        };
    }, [query]);
}
```

## State Management Parallelism

### useTransition for Smooth Updates
```javascript
function SearchComponent() {
    const [query, setQuery] = useState('');
    const [suggestions, setSuggestions] = useState([]);
    const [isPending, startTransition] = useTransition();

    const updateQuery = (newQuery) => {
        setQuery(newQuery);

        // Non-urgent suggestion update
        startTransition(async () => {
            const newSuggestions = await fetchSuggestions(newQuery);
            setSuggestions(newSuggestions);
        });
    };

    return (
        <div>
            <input
                value={query}
                onChange={(e) => updateQuery(e.target.value)}
            />
            {isPending && <Spinner />}
            <SuggestionsList suggestions={suggestions} />
        </div>
    );
}
```

### useDeferredValue for Debouncing
```javascript
function SearchResults({ query }) {
    const deferredQuery = useDeferredValue(query);
    const isStale = query !== deferredQuery;

    return (
        <div>
            {isStale && <Spinner />}
            <Results query={deferredQuery} />
        </div>
    );
}
```

## Performance Optimization

### Memoization to Prevent Unnecessary Work
```javascript
const ExpensiveComponent = memo(({ data }) => {
    const processedData = useMemo(() => {
        return expensiveTransformation(data);
    }, [data]);

    return <div>{processedData}</div>;
});

// Memoize callback functions
const handleClick = useCallback((item) => {
    processItem(item);
}, []);
```

### Virtual Scrolling for Large Lists
```javascript
import { FixedSizeList as List } from 'react-window';

function VirtualizedList({ items }) {
    const Row = ({ index, style }) => (
        <div style={style}>
            <ItemComponent item={items[index]} />
        </div>
    );

    return (
        <List
            height={600}
            itemCount={items.length}
            itemSize={50}
            width="100%"
        >
            {Row}
        </List>
    );
}
```

## Best Practices

### Avoid Blocking the Main Thread
```javascript
// Bad - blocking operation
function processLargeArray(array) {
    return array.map(expensiveTransform); // Blocks UI
}

// Good - chunked processing
function* processInChunks(array, chunkSize = 100) {
    for (let i = 0; i < array.length; i += chunkSize) {
        const chunk = array.slice(i, i + chunkSize);
        yield chunk.map(expensiveTransform);
        await new Promise(resolve => setTimeout(resolve, 0));
    }
}
```

### Proper Error Handling
```javascript
function AsyncComponent() {
    const [error, setError] = useState(null);
    const [data, setData] = useState(null);

    useEffect(() => {
        let cancelled = false;

        fetchData()
            .then(result => {
                if (!cancelled) setData(result);
            })
            .catch(err => {
                if (!cancelled) setError(err);
            });

        return () => {
            cancelled = true;
        };
    }, []);

    if (error) return <ErrorDisplay error={error} />;
    // ... render data
}
```

## Testing Parallel Code

### Mocking Async Operations
```javascript
// Test concurrent updates
test('handles rapid state changes', async () => {
    render(<Counter />);

    const button = screen.getByRole('button');
    fireEvent.click(button);
    fireEvent.click(button);
    fireEvent.click(button);

    // Wait for batched update
    await waitFor(() => {
        expect(screen.getByText('3')).toBeInTheDocument();
    });
});

// Test transition states
test('shows pending state during transition', async () => {
    render(<SearchComponent />);

    fireEvent.change(screen.getByRole('textbox'), {
        target: { value: 'test' }
    });

    expect(screen.getByRole('progressbar')).toBeInTheDocument();
});
```

## Browser Compatibility

- Concurrent features require React 18+
- Web Workers have broad browser support
- Consider polyfills for older browsers
- Test performance across different devices
</file>

<file path="React/PATTERNS.MD">
# React Design Patterns - Essentials

## Key Principle

Focus on component composition and state management rather than complex patterns.

## Essential Patterns

### Component Composition
**When to use**: Build reusable, flexible components

```jsx
// Container component
const UserList = ({ users, onSelect }) => (
  <div>
    {users.map(user => (
      <UserItem key={user.id} user={user} onClick={() => onSelect(user)} />
    ))}
  </div>
);

// Presentational component
const UserItem = ({ user, onClick }) => (
  <div onClick={onClick}>
    <h3>{user.name}</h3>
    <p>{user.email}</p>
  </div>
);
```

### Custom Hooks
**When to use**: Reuse stateful logic across components

```jsx
import { useState, useEffect } from 'react';

function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  });

  const setValue = (value) => {
    setStoredValue(value);
    window.localStorage.setItem(key, JSON.stringify(value));
  };

  return [storedValue, setValue];
}
```

### Context Provider
**When to use**: Share data across multiple components

```jsx
import React, { createContext, useContext, useState } from 'react';

const ThemeContext = createContext();

export const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState('light');

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
};
```

## Quick Reference

| Pattern | Problem | When to Use |
|---------|---------|-------------|
| Component Composition | Reusability | Building UI components |
| Custom Hooks | Logic reuse | Sharing stateful logic |
| Context | Prop drilling | Global state sharing |
| Render Props | Render flexibility | Component customization |

## Learning Approach

1. Master JSX and component basics first
2. Understand when to split components
3. Learn hooks before complex patterns
4. Practice with real-world examples
</file>

<file path="React/README.md">
# React Development Guidelines

## Overview

Essential guidelines and patterns for React development.

## Contents

- **PATTERNS.MD**: Essential React patterns with practical examples
- **IPC.MD**: Data fetching and state management techniques
- **Other guides**: Clean code, testing, static analysis, and performance optimization

## Getting Started

1. Understand component composition and custom hooks
2. Learn effective state management strategies
3. Follow React best practices for performance and maintainability

## Key Principles

- Keep components small and focused
- Separate concerns between UI and data logic
- Use hooks for stateful logic reuse
- Optimize performance with memoization and lazy loading
</file>

<file path="React/STATICANALYSIS.MD">
# React/JavaScript Static Analysis Tools

This document outlines the best static analysis tools for React/JavaScript that can be used via MCP or CLI.

## 1. ESLint

**Category**: Code quality, style, errors
**Integration**: CLI, IDE plugins
**MCP Support**: Via command execution

### Installation
```bash
npm install eslint --save-dev
# For React projects
npm install eslint-plugin-react eslint-plugin-react-hooks --save-dev
```

### Usage
```bash
# Initialize configuration
npx eslint --init

# Analyze specific files
npx eslint src/

# Fix automatically fixable issues
npx eslint src/ --fix

# Generate report in different formats
npx eslint src/ -f json > report.json
```

### Key Features
- Syntax error detection
- Code quality rules
- React-specific rules
- Auto-fix capabilities
- Plugin architecture

## 2. Prettier

**Category**: Code formatting
**Integration**: CLI, IDE plugins
**MCP Support**: Via command execution

### Installation
```bash
npm install prettier --save-dev
```

### Usage
```bash
# Format files
npx prettier --write src/

# Check formatting without modifying
npx prettier --check src/

# Format specific file types
npx prettier --write "**/*.{js,jsx,ts,tsx,json,css,md}"
```

### Key Features
- Opinionated code formatter
- Consistent styling
- Editor integration
- Configuration options
- Fast execution

## 3. TypeScript Compiler (tsc)

**Category**: Type checking
**Integration**: CLI
**MCP Support**: Via command execution

### Installation
```bash
npm install typescript --save-dev
# For React projects
npm install @types/react @types/react-dom --save-dev
```

### Usage
```bash
# Type check project
npx tsc

# Watch mode
npx tsc --watch

# Emit declaration files
npx tsc --declaration

# No emit mode (check only)
npx tsc --noEmit
```

### Key Features
- Static type checking
- Interface and type support
- Generic types
- Module resolution
- Incremental compilation

## 4. SonarJS

**Category**: Code quality, bug detection
**Integration**: CLI, SonarQube
**MCP Support**: Via command execution

### Installation
Part of SonarQube/SonarCloud or as standalone ESLint plugin:
```bash
npm install eslint-plugin-sonarjs --save-dev
```

### Usage
```bash
# As ESLint plugin
npx eslint src/

# With SonarQube Scanner
sonar-scanner
```

### Key Features
- Bug detection
- Code smell identification
- Cognitive complexity analysis
- Duplicated code detection
- Security hotspot identification

## 5. React-specific ESLint Plugins

### eslint-plugin-react-hooks
```bash
npm install eslint-plugin-react-hooks --save-dev
```

### eslint-plugin-jsx-a11y (Accessibility)
```bash
npm install eslint-plugin-jsx-a11y --save-dev
```

### Usage
```bash
# Configure in .eslintrc.js
module.exports = {
  plugins: ['react-hooks', 'jsx-a11y'],
  rules: {
    'react-hooks/rules-of-hooks': 'error',
    'react-hooks/exhaustive-deps': 'warn',
    'jsx-a11y/alt-text': 'warn',
  }
};
```

### Key Features
- React Hooks rules enforcement
- Accessibility compliance checking
- Best practices validation
- Automatic fix suggestions

## 6. Bundle Analysis Tools

### webpack-bundle-analyzer
```bash
npm install webpack-bundle-analyzer --save-dev
```

### Usage
```bash
# Analyze bundle size
npx webpack-bundle-analyzer build/static/js/main.*.js
```

### Key Features
- Bundle size visualization
- Dependency analysis
- Code splitting optimization
- Duplicate module detection
- Tree-shaking effectiveness

## 7. Jest (Testing as Analysis)

**Category**: Test coverage, code quality
**Integration**: CLI
**MCP Support**: Via command execution

### Installation
```bash
npm install jest @types/jest --save-dev
```

### Usage
```bash
# Run tests with coverage
npm test -- --coverage

# Generate coverage report
npm test -- --coverageReporters=json-summary

# Threshold enforcement
npm test -- --coverage --collectCoverageFrom="src/**/*.{js,jsx,ts,tsx}"
```

### Key Features
- Test coverage analysis
- Code quality through testing
- Snapshot testing
- Mocking capabilities
- CI/CD integration

## 8. Deprecation Checkers

### npm-check
```bash
npm install -g npm-check
```

### Usage
```bash
# Check for outdated dependencies
npm-check

# Check with update suggestions
npm-check -u
```

### Key Features
- Outdated dependency detection
- Security vulnerability checking
- Breaking change identification
- Update recommendations
- Interactive update mode

## 9. Security Analysis

### npm audit
```bash
# Built into npm
npm audit
```

### snyk
```bash
npm install -g snyk
snyk test
```

### Key Features
- Vulnerability detection
- License compliance
- Dependency tree analysis
- Fix suggestions
- CI/CD integration

## 10. Performance Analysis

### Lighthouse CI
```bash
npm install -g @lhci/cli
```

### Usage
```bash
# Run Lighthouse analysis
lhci autorun
```

### Key Features
- Performance metrics
- Accessibility scoring
- SEO analysis
- Best practices evaluation
- Progressive Web App compliance

## Recommended Tool Combination

For comprehensive React/JavaScript static analysis, we recommend using the following combination:

1. **ESLint** - Code quality and error detection
2. **Prettier** - Code formatting
3. **TypeScript** - Static type checking (for TypeScript projects)
4. **eslint-plugin-react-hooks** - React Hooks best practices
5. **eslint-plugin-jsx-a11y** - Accessibility compliance
6. **npm audit** - Security vulnerability detection
7. **webpack-bundle-analyzer** - Bundle size optimization

## CI/CD Integration Example

```yaml
# GitHub Actions example
- name: Install dependencies
  run: npm ci

- name: Run ESLint
  run: npx eslint src/ --ext .js,.jsx,.ts,.tsx

- name: Check formatting with Prettier
  run: npx prettier --check src/

- name: Type check with TypeScript
  run: npx tsc --noEmit

- name: Run security audit
  run: npm audit --audit-level moderate

- name: Run tests with coverage
  run: npm test -- --coverage --passWithNoTests

- name: Analyze bundle size
  run: npx webpack-bundle-analyzer build/static/js/*.js --mode static --report dist/report.html
```

## MCP Integration Approach

For MCP integration, you can execute these tools via command line and parse their output:

```javascript
const { exec } = require('child_process');

function runEslint(files) {
  return new Promise((resolve, reject) => {
    exec(`npx eslint ${files} --format json`, (error, stdout, stderr) => {
      if (error && !stdout) {
        reject(error);
      } else {
        try {
          const results = JSON.parse(stdout);
          resolve(results);
        } catch (parseError) {
          reject(parseError);
        }
      }
    });
  });
}

// Example usage in MCP
async function analyzeCode(files) {
  try {
    const eslintResults = await runEslint(files);
    eslintResults.forEach(result => {
      console.log(`File: ${result.filePath}`);
      result.messages.forEach(message => {
        console.log(`  Line ${message.line}: ${message.message} (${message.ruleId})`);
      });
    });
  } catch (error) {
    console.error('Analysis failed:', error);
  }
}
```

## Configuration Tips

1. **Shareable Configurations**: Use eslint-config-airbnb, eslint-config-standard-react
2. **IDE Integration**: Configure real-time feedback in VS Code/WebStorm
3. **Pre-commit Hooks**: Integrate with husky and lint-staged
4. **Performance Optimization**: Use cache and parallel processing
5. **Custom Rules**: Create organization-specific ESLint plugins
6. **Migration Strategy**: Gradually introduce rules with warning levels
7. **Baseline Creation**: Generate ignore files for legacy code issues
</file>

<file path="React/TESTING.MD">
# React Testing Guide

> **Note**: For general testing principles and common anti-patterns to avoid, please refer to the main [TESTING.MD](../TESTING.MD) file.

## State-of-the-Art Testing Frameworks

### Unit Testing Framework
**Jest** - Facebook's JavaScript testing framework, comes preconfigured with Create React App

### Component Testing Library
**React Testing Library** - The recommended way to test React components, focusing on user behavior

## Installation

If using Create React App, Jest is already included:
```bash
# Already included in CRA
```

For React Testing Library:
```bash
npm install --save-dev @testing-library/react @testing-library/jest-dom
```

## Unit Test Example

```javascript
import { render, screen, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import '@testing-library/jest-dom';
import UserProfile from './UserProfile';

// Mock component dependencies
jest.mock('./services/api', () => ({
  getUser: jest.fn()
}));

describe('UserProfile', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('displays user name when user is loaded', async () => {
    // Arrange
    const mockUser = { id: 1, name: 'John Doe', email: 'john@example.com' };
    require('./services/api').getUser.mockResolvedValue(mockUser);

    // Act
    render(<UserProfile userId={1} />);

    // Assert
    expect(screen.getByText('Loading...')).toBeInTheDocument();
    expect(await screen.findByText('John Doe')).toBeInTheDocument();
    expect(screen.getByText('john@example.com')).toBeInTheDocument();
  }, 60000); // 1 minute timeout

  test('calls onDelete when delete button is clicked', async () => {
    // Arrange
    const mockUser = { id: 1, name: 'John Doe', email: 'john@example.com' };
    const mockDelete = jest.fn();
    require('./services/api').getUser.mockResolvedValue(mockUser);

    render(<UserProfile userId={1} onDelete={mockDelete} />);
    await screen.findByText('John Doe');

    // Act
    const deleteButton = screen.getByRole('button', { name: 'Delete' });
    await userEvent.click(deleteButton);

    // Assert
    expect(mockDelete).toHaveBeenCalledWith(1);
  }, 60000); // 1 minute timeout

  test('shows error message when user loading fails', async () => {
    // Arrange
    require('./services/api').getUser.mockRejectedValue(new Error('User not found'));

    // Act
    render(<UserProfile userId={999} />);

    // Assert
    expect(await screen.findByText('Failed to load user')).toBeInTheDocument();
  }, 60000); // 1 minute timeout
});
```

## Integration Test Example

```javascript
import { render, screen } from '@testing-library/react';
import { BrowserRouter } from 'react-router-dom';
import userEvent from '@testing-library/user-event';
import App from './App';

// Mock API calls
global.fetch = jest.fn();

describe('App Integration', () => {
  beforeEach(() => {
    fetch.mockClear();
  });

  test('user can navigate to profile and see user details', async () => {
    // Arrange
    const mockUsers = [
      { id: 1, name: 'John Doe', email: 'john@example.com' }
    ];

    fetch.mockResolvedValueOnce({
      json: () => Promise.resolve(mockUsers),
      ok: true
    });

    // Act
    render(
      <BrowserRouter>
        <App />
      </BrowserRouter>
    );

    // Navigate to users page
    const usersLink = screen.getByRole('link', { name: 'Users' });
    await userEvent.click(usersLink);

    // Assert
    expect(await screen.findByText('John Doe')).toBeInTheDocument();

    // Click on user to view details
    const userLink = screen.getByRole('link', { name: 'John Doe' });
    await userEvent.click(userLink);

    expect(await screen.findByText('john@example.com')).toBeInTheDocument();
  }, 300000); // 5 minutes timeout
});
```

## End-to-End Test Example

```javascript
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import App from './App';

describe('Full Application Workflow', () => {
  test('complete user registration and profile management workflow', async () => {
    // Arrange
    const startTime = Date.now();

    // Act
    render(<App />);

    // Navigate to registration
    const registerLink = screen.getByRole('link', { name: 'Register' });
    await userEvent.click(registerLink);

    // Fill registration form
    const nameInput = screen.getByLabelText('Name');
    const emailInput = screen.getByLabelText('Email');
    await userEvent.type(nameInput, 'Test User');
    await userEvent.type(emailInput, 'test@example.com');

    const submitButton = screen.getByRole('button', { name: 'Register' });
    await userEvent.click(submitButton);

    // Verify profile creation
    expect(await screen.findByText('Welcome, Test User')).toBeInTheDocument();

    // Update profile
    const editButton = screen.getByRole('button', { name: 'Edit Profile' });
    await userEvent.click(editButton);

    const bioInput = screen.getByLabelText('Bio');
    await userEvent.type(bioInput, 'This is my bio');

    const saveButton = screen.getByRole('button', { name: 'Save' });
    await userEvent.click(saveButton);

    // Verify update
    expect(await screen.findByText('Profile updated successfully')).toBeInTheDocument();

    const endTime = Date.now();
    const duration = endTime - startTime;

    // Assert
    expect(duration).toBeLessThan(600000); // 10 minutes timeout
  }, 600000); // 10 minutes timeout
});
```

## Jest Configuration for Timeouts

Add to your `jest.config.js` or in `package.json`:

```javascript
// jest.config.js
module.exports = {
  // ... other config
  testTimeout: 60000, // 1 minute default timeout
  // ... other config
};
```

Or in `package.json`:
```json
{
  "jest": {
    "testTimeout": 60000
  }
}
```

## Best Practices

1. Use React Testing Library for component tests (focus on user behavior)
2. Test user interactions rather than implementation details
3. Mock external dependencies like API calls
4. Use descriptive test names that explain the behavior
5. Follow the AAA pattern (Arrange, Act, Assert)
6. Test both happy paths and error conditions
7. Use async/await for asynchronous operations
8. Clean up mocks between tests
9. Use data-testid attributes sparingly, prefer semantic queries
10. Separate unit and integration tests
11. Test edge cases and boundary conditions
12. Use jest.mock() for mocking modules
13. Use fake timers for time-dependent code
14. **Always set timeouts: 1 minute for unit tests, 5 minutes for integration tests, 10 minutes for end-to-end tests**
15. Set test timeouts as the second parameter to test functions
16. Configure default timeouts in Jest configuration
17. Monitor test execution times to identify performance regressions
18. Use jest.setTimeout() for global timeout configuration when needed
19. **Keep unit tests concise: maximum 10 lines of code (LOC), up to 20 LOC with explanatory comment**

## Mocking Anti-Patterns to Avoid

1. **The Mockery**: Avoid excessive mocking that tests mock interactions rather than real behavior. This often indicates components with too many dependencies.

2. **Overusing Mocks for Implementation Details**: Don't mock to assert on internal component structure or private behaviors. Focus on testing observable user interactions rather than implementation specifics.

3. **Leaky Mocks**: Ensure mocks don't leak between tests. Each test should have isolated mock configurations to maintain consistency.

4. **Mocking Everything Indiscriminately**: Don't mock all dependencies by default. Use mocks sparingly for true isolation, preferring fakes or stubs for simpler simulations.

Focus on testing behavior over internals. If mocking feels excessive, it might signal design issues like components with too many responsibilities.
</file>

<file path="templates/ADR-TEMPLATE.MD">
# ADR-[NUMBER]: [Title]

## Status
[Proposed | Accepted | Superseded by ADR-X]

## Context
Describe the forces at play, including technological, political, social, and project local factors. These forces are likely in tension, and should be called out as such.

## Decision
State the decision that was made. This should be a simple statement, with no justification or discussion.

## Consequences
Describe the resulting context, after applying the decision. All consequences should be listed here, not just the "positive" ones. A particular decision may have positive, negative, and neutral consequences, but all of them affect the team and project in the future.

## Alternatives Considered
List alternative options that were considered, along with a brief reason why they were not chosen.

## References
Link to supporting documents, issues, or related ADRs.
</file>

<file path="templates/API-DESIGN-TEMPLATE.MD">
# [API Name] API Design

## Overview
Brief description of the API's purpose and scope.

## Base URL
```
[Base URL for the API]
```

## Authentication
Description of authentication mechanism.

## Endpoints

### [Resource Name]

#### `GET /[endpoint]`
**Description**: What this endpoint does

**Parameters**:
| Name | Type | In | Required | Description |
|------|------|----|----------|-------------|
| param1 | string | query/path/header | Yes | Description |

**Responses**:
| Code | Description |
|------|-------------|
| 200 | Success response |
| 400 | Bad request |
| 401 | Unauthorized |
| 500 | Internal server error |

**Example Request**:
```http
GET /[endpoint]?param=value HTTP/1.1
Host: [host]
Authorization: [auth]
```

**Example Response**:
```json
{
  "data": {}
}
```

## Error Handling
Standard error response format:
```json
{
  "error": {
    "code": "ERROR_CODE",
    "message": "Human readable message",
    "details": {}
  }
}
```

## Rate Limiting
Description of rate limiting policies.

## Versioning
How API versions are managed.

## Security Considerations
Security measures and best practices.
</file>

<file path="templates/CODE-REVIEW-CHECKLIST.MD">
# Code Review Checklist

## General Principles
- [ ] Code follows established style guides
- [ ] Code is self-documenting with clear variable/function names
- [ ] Code has appropriate comments explaining "why" not "what"
- [ ] No commented-out code or unnecessary logging
- [ ] Code handles errors appropriately

## Design & Architecture
- [ ] Code follows SOLID principles
- [ ] Functions are small and focused (single responsibility)
- [ ] No duplicated logic (DRY principle)
- [ ] Dependencies are minimized and properly managed
- [ ] Code is testable and loosely coupled

## Security
- [ ] Input validation is implemented
- [ ] Sensitive data is not logged
- [ ] Authentication/authorization is properly handled
- [ ] SQL injection/XSS prevention measures are in place
- [ ] Dependencies are up-to-date with no known vulnerabilities

## Performance
- [ ] Algorithms are efficient for expected data sizes
- [ ] Database queries are optimized
- [ ] Caching strategies are appropriate
- [ ] Memory leaks are prevented
- [ ] Asynchronous operations are used where appropriate

## Testing
- [ ] New code is covered by unit tests
- [ ] Edge cases are tested
- [ ] Integration tests cover key workflows
- [ ] Test names clearly describe expected behavior
- [ ] Tests are independent and repeatable

## Documentation
- [ ] Public APIs are documented
- [ ] Complex logic is explained
- [ ] README updates are included if needed
- [ ] Changelog is updated for user-facing changes

## Deployment & Operations
- [ ] Configuration is externalized
- [ ] Logging is appropriate for debugging
- [ ] Monitoring/metrics are in place
- [ ] Backward compatibility is maintained
- [ ] Rollback strategy is considered
</file>

<file path="templates/GUIDELINES-TEMPLATE.MD">
# [Technology/Domain] Guidelines

This document outlines best practices and guidelines for [technology/domain] development within our projects.

## Key Principles

- [Principle 1 with brief explanation]
- [Principle 2 with brief explanation]
- [Principle 3 with brief explanation]

## Core Concepts

### [Core Concept 1]
[Brief description of the concept and its importance]

```[appropriate_language]
// Code example demonstrating the concept
```

### [Core Concept 2]
[Brief description of the concept and its importance]

```[appropriate_language]
// Code example demonstrating the concept
```

## Implementation Guidelines

### [Implementation Area 1]
[Guidelines and best practices for this area]

### [Implementation Area 2]
[Guidelines and best practices for this area]

## Best Practices

- [Best practice 1 with rationale]
- [Best practice 2 with rationale]
- [Best practice 3 with rationale]

## Common Pitfalls

- [Pitfall 1 and how to avoid it]
- [Pitfall 2 and how to avoid it]
- [Pitfall 3 and how to avoid it]

## Testing Strategies

[Recommended approaches for testing this technology/domain]

## Performance Considerations

[Performance tips and optimization strategies]

## Security Considerations

[Security best practices and considerations]

## Quick Reference

| Aspect | Recommendation |
|--------|----------------|
| Key Libraries/Modules | [main libraries for this functionality] |
| Primary Pattern | [most common pattern] |
| Common Mistake | [frequent error to avoid] |

_Last Updated: [Date]_
_Next Review: [Date + 6 months]_

## See Also

- [Related documentation links]
- [External resources]
</file>

<file path="templates/INCIDENT-REPORT-TEMPLATE.MD">
# Incident Report: [Brief Title]

## Summary
Brief overview of the incident including impact and resolution time.

## Timeline
| Time (UTC) | Event |
|------------|-------|
| YYYY-MM-DD HH:MM | Incident detected |
| YYYY-MM-DD HH:MM | Investigation began |
| YYYY-MM-DD HH:MM | Root cause identified |
| YYYY-MM-DD HH:MM | Mitigation implemented |
| YYYY-MM-DD HH:MM | Service restored |

## Impact
- **Services affected**: [List affected services]
- **Duration**: [Start time] to [End time]
- **Users affected**: [Estimated number or percentage]
- **Business impact**: [Description of business impact]

## Root Cause Analysis
### Immediate Cause
Description of the direct cause of the incident.

### Contributing Factors
- [Factor 1]
- [Factor 2]

### Trigger
What triggered the incident to manifest?

## Resolution
Steps taken to resolve the incident:
1. [Step 1]
2. [Step 2]

## Lessons Learned
Key takeaways from the incident:
- [Lesson 1]
- [Lesson 2]

## Action Items
| Item | Owner | Due Date | Status |
|------|-------|----------|--------|
| [Action 1] | [Owner] | [Date] | [Status] |
| [Action 2] | [Owner] | [Date] | [Status] |

## Preventive Measures
Long-term measures to prevent recurrence:
- [Measure 1]
- [Measure 2]

---
**Reported by**: [Name]
**Date**: [YYYY-MM-DD]
**Last Updated**: [YYYY-MM-DD]
</file>

<file path="templates/PATTERN-TEMPLATE.MD">
# [Pattern Name] Pattern

## Intent
Describe what the pattern is supposed to achieve.

## Motivation
Explain the problem the pattern solves with a concrete example.

## Applicability
When should this pattern be used?

## Structure
Describe the pattern's structure with a class diagram or description of relationships.

## Participants
List the classes/objects involved in the pattern:
- [Participant 1]: [Role]
- [Participant 2]: [Role]

## Collaborations
Describe how participants collaborate.

## Consequences
What are the trade-offs of using this pattern?

## Implementation
Guidelines for implementing the pattern:
- [Guideline 1]
- [Guideline 2]

## Sample Code
```[language]
// Example implementation
```

## Known Uses
Where has this pattern been used?

## Related Patterns
How does this pattern relate to others?
</file>

<file path="ARCHITECT.MD">
# Architecture Decision Principles

This document outlines the principles for making and documenting architecture decisions in software projects.

## Architecture Decision Records (ADRs)

All significant architecture decisions must be recorded as Architecture Decision Records (ADRs) to ensure transparency, traceability, and knowledge sharing.

### ADR Format

Each ADR should follow this structure:

1. **Title**: Brief, descriptive title of the decision
2. **Status**: Proposed, Accepted, Deprecated, Superseded
3. **Context**: Problem statement and driving forces
4. **Decision**: Chosen approach and rationale
5. **Consequences**: Positive and negative outcomes
6. **Alternatives**: Considered options and why they were rejected

### When to Create an ADR

Create an ADR for decisions that:
- Affect the system's structure or behavior
- Have significant cost or risk implications
- Are difficult to change later
- Impact multiple teams or components
- Involve technology selection
- Address cross-cutting concerns (security, performance, scalability)

## Design Principles

### 1. Separation of Concerns
- Divide system into distinct features with minimal overlap
- Each module should have a single responsibility
- Clear boundaries between components

### 2. Modularity
- Design components that can be developed, tested, and deployed independently
- Minimize dependencies between modules
- Use well-defined interfaces

### 3. Scalability
- Design for horizontal scaling when possible
- Consider performance implications of design choices
- Plan for growth in users, data, and traffic

### 4. Maintainability
- Favor simplicity over cleverness
- Write code that is easy to understand and modify
- Document complex decisions and trade-offs

### 5. Security
- Apply security principles by design
- Follow principle of least privilege
- Consider threat modeling for critical components

## Documentation Standards

### C4 Model
Use the C4 model for architecture visualization:
- **Context**: System landscape and external dependencies
- **Containers**: High-level technical decomposition
- **Components**: Detailed decomposition of containers
- **Code**: Implementation details (UML diagrams, code snippets)

### Diagram Guidelines
- Keep diagrams simple and focused
- Use consistent notation and style
- Include legends for custom symbols
- Maintain diagrams alongside code
- Reference diagrams in ADRs when relevant
</file>

<file path="CLEANCODE.MD">
# Clean Code Principles

This document outlines the principles for writing clean, maintainable code across all languages and frameworks.

## Key Principles

### 1. Meaningful Names
- Use intention-revealing names for variables, functions, and classes
- Avoid disinformation and noise words (data, info, manager)
- Make meaningful distinctions between similar concepts
- Use pronounceable and searchable names

### 2. Functions
- Keep functions small and focused on a single responsibility
- Functions should do one thing and do it well
- Use function names that clearly express their purpose
- Minimize the number of function arguments (ideally < 3)

### 3. Comments
- Express yourself in code rather than comments when possible
- Comments should explain "why" not "what"
- Keep comments up to date with code changes
- Remove commented-out code

### 4. Formatting
- Maintain consistent indentation and spacing
- Place related concepts near each other
- Order functions from high-level to low-level abstraction
- Keep lines reasonably short (generally < 100 characters)

### 5. Error Handling
- Use exceptions rather than return codes
- Handle errors at the appropriate level
- Don't return or pass null
- Provide context with exceptions

### 6. Boundaries
- Encapsulate third-party library dependencies
- Avoid passing raw boundary interfaces inward
- Use Adapter pattern to convert foreign interfaces
- Minimize exposure to third-party code

## Language-Specific Guidelines

Refer to language-specific directories for implementation details:
- [C# Clean Code](./C#/CLEANCODE.MD)
- [C++ Clean Code](./C++/CLEANCODE.MD)
- [React Clean Code](./React/CLEANCODE.MD)
- [Python Clean Code](./Python/CLEANCODE.MD)
</file>

<file path="COMMIT.MD">
# Commit Message Standards

This document outlines the standards for writing clear, informative commit messages that enhance project history and collaboration.

## Commit Message Format

Follow the conventional commit format:

```
<type>(<scope>): <subject>

<body>

<footer>
```

### Types
- **feat**: A new feature
- **fix**: A bug fix
- **docs**: Documentation only changes
- **style**: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)
- **refactor**: A code change that neither fixes a bug nor adds a feature
- **perf**: A code change that improves performance
- **test**: Adding missing tests or correcting existing tests
- **build**: Changes that affect the build system or external dependencies
- **ci**: Changes to our CI configuration files and scripts
- **chore**: Other changes that don't modify src or test files

### Scope
The scope should be the name of the module, component, or area affected by the change.

### Subject
- Use imperative, present tense ("change" not "changed" or "changes")
- Don't capitalize the first letter
- No period (.) at the end
- Keep it concise (typically < 50 characters)

### Body
- Just as in the subject, use imperative, present tense
- Include the motivation for the change and contrast this with previous behavior
- Wrap lines at 72 characters

### Footer
- Reference issues closed by this commit (e.g., "Fixes #123", "Closes #456")
- Reference breaking changes with "BREAKING CHANGE:" prefix

## Examples

Good commit messages:

```
feat(auth): add password reset functionality

Implement password reset flow including email verification
and token expiration handling.

Closes #1234
```

```
fix(api): resolve race condition in user updates

Use database transactions to ensure atomic updates
when modifying user profile data.

Fixes #5678
```

```
docs(readme): update installation instructions

Add detailed steps for different operating systems
and clarify dependency requirements.
```

## Best Practices

1. **Atomic Commits**: Each commit should represent a single logical change
2. **Frequent Commits**: Commit small, focused changes regularly
3. **Clear Separation**: Separate subject from body with a blank line
4. **Consistent Language**: Use the same language throughout the project
5. **Reference Issues**: Always reference related issues or tickets
6. **Avoid Vague Messages**: Don't use messages like "fix bug" or "update code"
</file>

<file path="COORDINATION.MD">
## Universal Workflow Approach

- Break down complex problems into manageable pieces

### 2. Solution Design
- Explore multiple approaches
- Consider trade-offs between simplicity and functionality
- Document key decisions and rationale

### 3. Implementation
- Follow established coding standards
- Use version control with meaningful commits
- Conduct regular check-ins and progress updates

### 4. Review & Improvement
- Perform peer reviews with constructive feedback
- Test functionality against requirements
- Gather feedback and iterate as needed

## Cross-Language Communication Guidelines

### Team Meetings
- Daily standups: Yesterday, Today, Blockers
- Weekly retrospectives: What went well, What didn't, Improvements
- Planning sessions: Prioritize work and estimate effort

### Knowledge Sharing
- Keep documentation close to the code
- Use README files for project-level information
- Create simple examples to illustrate concepts

### Decision Making
- Involve the right people in decisions
- Document architectural choices
- Revisit decisions when circumstances change

## General Tools & Practices

### Recommended Tools
- **Project Management**: Jira, Trello, Asana, or GitHub Projects
- **Version Control**: Git with feature branches and pull requests
- **CI/CD**: GitHub Actions, GitLab CI, or similar platforms
- **Communication**: Slack, Teams, Discord, or email

### Best Practices
- Write code that's easy to read and maintain
- Automate testing and deployment when possible
- Keep processes lightweight and adaptable
- Focus on delivering value to users
- Regular retrospectives to improve team effectiveness

## When to Consider Complex Systems

Only add complexity when:
- Team size exceeds what can be effectively managed with simple processes
- Distributed teams require formal coordination
- Regulatory or compliance requirements demand detailed tracking
- Simple approaches have proven inadequate for specific needs

## Language-Specific Guidance

For detailed guidance on specific languages and frameworks, see:
- [C# Development](./C#/README.md)
- [C++ Development](./C++/README.md)
- [React Development](./React/README.md)
- [Python Development](./Python/README.md)

The goal is to provide enough guidance for effective development while avoiding the bureaucratic overhead that can hinder productivity.
</file>

<file path="IPC.MD">
# Inter-Process Communication (IPC) Guidelines

Inter-Process Communication enables processes to exchange data and coordinate actions. Choose the right IPC mechanism based on performance, complexity, and integration requirements.

## IPC Mechanisms Overview

### Network-Based IPC
- **REST/OpenAPI**: HTTP-based, human-readable, widely supported
- **gRPC/Protobuf**: High-performance, strongly-typed, efficient serialization
- **Message Queues**: Asynchronous, reliable message passing

### OS-Level IPC
- **Pipes**: Unidirectional data flow, simple communication
- **Shared Memory**: Fast, direct memory access between processes
- **Sockets**: Flexible network communication (Unix domain, TCP/IP)

## REST/OpenAPI

### When to Use
- Web applications and microservices
- Human-readable APIs for debugging
- Integration with diverse clients
- Loose coupling between services

### Best Practices

**API Design**
```
GET /api/v1/users/{id}
POST /api/v1/users
PUT /api/v1/users/{id}
DELETE /api/v1/users/{id}
```

**Response Structure**
```json
{
  "data": {...},
  "meta": {
    "timestamp": "2023-01-01T00:00:00Z",
    "version": "1.0"
  }
}
```

**Error Handling**
```json
{
  "error": {
    "code": "USER_NOT_FOUND",
    "message": "User with ID 123 not found",
    "details": {...}
  }
}
```

### OpenAPI Specification
```yaml
openapi: 3.0.0
info:
  title: User Service API
  version: 1.0.0

paths:
  /users/{id}:
    get:
      summary: Get user by ID
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        '200':
          description: User found
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
```

## gRPC/Protocol Buffers

### When to Use
- High-performance internal services
- Strongly-typed contracts
- Polyglot environments
- Streaming requirements

### Protocol Buffer Definition
```protobuf
syntax = "proto3";

package user;

service UserService {
  rpc GetUser(GetUserRequest) returns (GetUserResponse);
  rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);
  rpc StreamUsers(StreamUsersRequest) returns (stream User);
}

message GetUserRequest {
  int32 id = 1;
}

message User {
  int32 id = 1;
  string name = 2;
  string email = 3;
}

message GetUserResponse {
  User user = 1;
  Error error = 2;
}

message Error {
  string code = 1;
  string message = 2;
}
```

### gRPC Service Implementation
```go
type UserService struct {
    pb.UnimplementedUserServiceServer
}

func (s *UserService) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.GetUserResponse, error) {
    // Implementation
    return &pb.GetUserResponse{User: user}, nil
}
```

### Best Practices
- Define clear service contracts
- Use appropriate gRPC status codes
- Implement proper error handling
- Consider bidirectional streaming for real-time communication

## Message Queues

### When to Use
- Decoupled system components
- Reliable message delivery
- Load leveling and buffering
- Event-driven architectures

### Common Patterns

**Publish-Subscribe**
```python
# Publisher
channel.basic_publish(
    exchange='user_events',
    routing_key='user.created',
    body=json.dumps(user_data)
)

# Subscriber
def callback(ch, method, properties, body):
    process_user_event(json.loads(body))

channel.basic_consume(queue='user_created', on_message_callback=callback)
```

**Request-Reply**
```java
// Send request
String correlationId = UUID.randomUUID().toString();
Message request = MessageBuilder
    .withPayload(data)
    .setCorrelationId(correlationId)
    .build();

// Receive reply
Message reply = requestReplyTemplate.sendAndReceive("requests", request);
```

## Choosing the Right IPC Mechanism

### Decision Matrix

| Requirement | REST | gRPC | Message Queue | Shared Memory |
|-------------|------|------|---------------|---------------|
| Performance | Medium | High | Medium | Very High |
| Human Readable | Yes | No | No | No |
| Streaming | Limited | Yes | Yes | No |
| Language Agnostic | Yes | Yes | Yes | Limited |
| Error Handling | Standard HTTP | Rich Status Codes | Custom | Manual |
| Discovery | Manual/OpenAPI | Protobuf/gRPC | Broker-based | Manual |

### Use Cases

**REST/OpenAPI**
- Public APIs
- Web frontends
- Third-party integrations
- Rapid prototyping

**gRPC/Protobuf**
- Microservices communication
- Mobile backends
- Real-time streaming
- Polyglot systems

**Message Queues**
- Event sourcing
- Background processing
- Load distribution
- System decoupling

**OS-Level IPC**
- High-performance computing
- System utilities
- Embedded systems
- Low-latency requirements

## Security Considerations

### Authentication
- Use OAuth 2.0 for REST APIs
- Implement mutual TLS for gRPC
- Secure message queues with SASL/SSL

### Authorization
- JWT tokens with claims
- Role-based access control
- Fine-grained permissions

### Data Protection
- Encrypt sensitive data in transit
- Validate and sanitize inputs
- Implement rate limiting
- Use secure serialization formats

## Performance Optimization

### REST
- Implement caching (ETag, Cache-Control)
- Use compression (gzip, brotli)
- Optimize payload sizes
- Connection pooling

### gRPC
- Use connection multiplexing
- Enable compression
- Batch requests when appropriate
- Monitor streaming connections

### General
- Monitor latency and throughput
- Implement circuit breakers
- Use appropriate timeouts
- Load test under realistic conditions

## Monitoring and Observability

### Logging
- Structured logging with correlation IDs
- Context propagation across services
- Error tracking and alerting

### Metrics
- Request/response latency
- Throughput and error rates
- Resource utilization
- Distributed tracing

### Health Checks
```http
GET /health
Response: 200 OK
{
  "status": "healthy",
  "checks": [
    {
      "name": "database",
      "status": "ok"
    }
  ]
}
```

Effective IPC design balances performance, maintainability, and operational concerns while meeting business requirements.

## Quick Reference

- **REST/OpenAPI**: Best for web APIs, public interfaces, and human-readable communication
- **gRPC/Protobuf**: Ideal for high-performance microservices and polyglot environments
- **Message Queues**: Essential for asynchronous communication and event-driven architectures
- **Shared Memory**: Optimal for high-speed, low-latency communication within the same machine
- **Sockets**: Versatile for both local and network communication
- **Pipes**: Simple for unidirectional data flow between related processes

## Decision Framework

1. **Performance Needs**: Shared Memory > gRPC > Message Queues > REST
2. **Complexity Tolerance**: REST < Pipes < Sockets < Message Queues < gRPC
3. **Language Diversity**: REST/gRPC > Message Queues > Shared Memory/Pipes
4. **Reliability Requirements**: Message Queues > gRPC > REST > Sockets/Pipes

_Last Updated: 2025-09-21_
_Next Review: 2026-03-21_

## See Also

- [C# IPC Guidelines](./C#/IPC.MD)
- [C++ IPC Guidelines](./C++/IPC.MD)
- [Python IPC Guidelines](./Python/IPC.MD)
- [React IPC Guidelines](./React/IPC.MD)
</file>

<file path="PATTERNS.MD">
# Design Patterns Usage Policy (WHEN / HOW / WHEN NOT  Behavioral  Structural  Creational)

> Drop-in rules for your **AGENTS.md**. Tells the agent **when** to propose a pattern, **how** to implement it minimally, and **when not** to (avoid overengineering). Uses strong, testable criteria.

> **Note**: Concrete implementation examples for each programming language can be found in the respective subfolder PATTERNS.MD files:
> - [C# Patterns Examples](./C#/PATTERNS.MD)
> - [C++ Patterns Examples](./C++/PATTERNS.MD)
> - [Python Patterns Examples](./Python/PATTERNS.MD)
> - [React Patterns Examples](./React/PATTERNS.MD)

## Role Definition

You are the **Patterns Advisor Agent**. You detect design smells, recommend **the simplest viable pattern**, outline **minimal steps**, and refuse patterns when they would add needless complexity.

## Objective

Improve clarity, flexibility, and testability **only when justified by concrete smells or requirements**. Prefer refactorings with **small diffs** and **clear tests** over speculative abstractions.

## Guardrails (applies to all patterns)

* **Must** cite the triggering smell(s) and the benefit (testability, decoupling, reuse).

* **Must not** add >3 new types or >150 LOC without explicit justification.

* **YAGNI:** If no immediate client or test uses the new seam, **do not introduce** a pattern.

* **Bench budget:** If pattern adds a dispatch/hop, estimate latency/alloc impact; abort if it breaks budgets.

* **Tests first:** Add/adjust tests that prove the need and lock in behavior.

## Decision Workflow (always follow)

1. **Identify Smell(s):** rigidity, shotgun changes, long conditionals, duplicated algorithms, chatty coupling, unstable dependency, global state, etc.

2. **Map Smell  Candidate Pattern(s)** (see below).

3. **Try the lowest-cost alternative first** (function parameter, small interface) before a full pattern.

4. **Propose Minimal Plan:** files to touch, interfaces, quick sketch.

5. **Add/Update Tests.**

6. **Refactor in small steps**; measure impact (perf + readability).

7. **Stop** when the smell is resolved. Do **not** "collect them all."

---

## Behavioral Patterns

### Chain of Responsibility

* **Use when**: Multiple conditional handlers (`if/else` ladder), optional steps, or policy chains that vary by tenant/feature.

* **How**: Define `IHandler.handle(Request) -> Optional<Response>`; link next; move each branch into a handler; add a terminator.

* **Avoid/Overengineering**: If only 2 branches or order is fixed and smallprefer a simple switch or strategy map.

### Command

* **Use when**: You need undo/redo, queue/defer/retry requests, or audit/serialize actions.

* **How**: Create `Command { execute(); undo(); serialize(); }`; keep minimal state; wrap invocation sites; add command bus.

* **Avoid**: If you never undo/queue or inspect actions, a plain function call suffices.

### Iterator

* **Use when**: You must traverse without exposing internals or you need lazy streaming.

* **How**: Expose `begin()/end()` or `next()`; hide storage; add sentinel completion.

* **Avoid**: If your collection is already standard-iterableuse the language's iterator.

### Mediator

* **Use when**: Many-to-many interactions cause combinatorial dependencies (widgets talking to each other, chatty modules).

* **How**: Introduce `Mediator` that owns interactions/events; colleagues talk only to mediator.

* **Avoid**: For 23 components with stable coupling, direct calls are clearer.

### Memento

* **Use when**: Need snapshot/restore of object state (undo, drafts, speculative exec) **without** exposing internals.

* **How**: Add `createMemento()/restore(m)`; keep memento immutable; scope lifetime carefully.

* **Avoid**: If state is trivial or you already have persistence/versioning.

### Observer

* **Use when**: One-to-many updates, plugin points, or cross-cutting events (telemetry, cache invalidation).

* **How**: Define `subscribe(event, fn)`; ensure async safety; prevent leaks (weak refs/unsubscribe).

* **Avoid**: If there's exactly one consumer, or events are synchronous and localprefer direct call.

### State

* **Use when**: Behavior changes with internal state and `if (mode)` branches proliferate.

* **How**: Encode states as classes with same interface; context delegates to current state; transitions explicit.

* **Avoid**: If states 2 and rarely changeguard clauses may be simpler.

### Strategy

* **Use when**: You have a family of algorithms (pricing, hashing, route selection) chosen at runtime/build-time.

* **How**: Define `IStrategy.execute(input)`; inject or map by key; keep strategies stateless if possible.

* **Avoid**: If there's only one algorithm or switching is unlikely.

### Template Method

* **Use when**: Algorithms share skeleton with few variable steps; subclasses fill hooks.

* **How**: Base class implements invariant steps; `protected hook()` methods for variation.

* **Avoid**: If variation points are many/optionalprefer **Strategy** or composition.

### Visitor

* **Use when**: Need to run multiple independent operations over a stable object hierarchy (AST, schema).

* **How**: Add `accept(Visitor)`; implement visitors per operation; keep hierarchy closed.

* **Avoid**: If hierarchy changes ofteneach change breaks all visitors; consider pattern matching.

---

## Structural Patterns

### Adapter

* **Use when**: Integrating an incompatible API without touching the target.

* **How**: Wrap foreign API; translate types/errors; keep adapter thin.

* **Avoid**: If you control both sideschange the interface directly.

### Bridge

* **Use when**: You have a product matrix (Abstraction  Implementation) exploding subclasses.

* **How**: Split into two hierarchies; inject implementation into abstraction.

* **Avoid**: If variations are few and stablesimple inheritance may suffice.

### Composite

* **Use when**: You need to treat part-whole uniformly (trees: UI, filesystems, org charts).

* **How**: Define `Component` with common ops; `Leaf` and `Composite` implement it; recurse.

* **Avoid**: If structure isn't truly hierarchical or operations differ wildly.

### Decorator

* **Use when**: Add cross-cutting features per instance at runtime (logging, caching, metrics).

* **How**: Wrap with same interface; delegate and augment; stackable.

* **Avoid**: If you only need one global enhancementsimpler to put it in the impl or behind a flag.

### Facade

* **Use when**: Clients struggle with a complex subsystem; you want stable entrypoints.

* **How**: Create thin faade functions/classes; hide wiring; keep it **stateless** if possible.

* **Avoid**: If the subsystem is already simple; don't add a faade that just renames things.

### Flyweight

* **Use when**: Millions of similar objects strain RAM; large shared intrinsic state.

* **How**: Separate intrinsic vs extrinsic state; pool/reuse intrinsic.

* **Avoid**: If memory is fine or identity semantics matter per-instance.

### Proxy

* **Use when**: Control access (lazy load, remote, cache, auth).

* **How**: Implement same interface; add before/after policy; surface errors clearly.

* **Avoid**: If you can call the thing directly and don't need control points.

---

## Creational Patterns

### Factory Method

* **Use when**: Subclasses decide which product to create; you want to decouple creation from use.

* **How**: Define `create()` in base; override in subclass; return interface.

* **Avoid**: If a single constructor worksdon't hide it behind a factory.

### Abstract Factory

* **Use when**: You create **families** of related objects that must vary together (theme, driver stack).

* **How**: Define factory interface with related creators; inject concrete factory.

* **Avoid**: If you only need one productFactory Method or plain constructor.

### Builder

* **Use when**: Constructing complex objects step-by-step with optional parts or validation.

* **How**: Fluent setters accumulating state; `build()` validates and returns immutable product.

* **Avoid**: If the object has 3 parametersprefer a constructor with named args/struct.

### Prototype

* **Use when**: Cloning preconfigured instances is cheaper/simpler than constructing from scratch.

* **How**: Provide `clone()`; deep-copy where needed; keep prototypes registered.

* **Avoid**: If copy semantics are unclear/unsafe (shared ownership, native handles).

### Singleton

* **Use when**: You truly need exactly one instance with shared state (rare: process-wide config).

* **How**: Private ctor + accessor; thread-safe init; **allow dependency injection for tests**.

* **Avoid (strongly)**: Most casescreates hidden coupling, test pain, order-of-init bugs.

---

## When **NOT** to use patterns (global)

* No measurable smell or requirement; adding an abstraction **just in case**.

* Pattern introduces **more types than it removes conditionals**.

* You can solve it with **a pure function + parameter** (e.g., pass comparator instead of Strategy class).

* Pattern obscures control flow critical for correctness (security/transactions).

* Perf/latency budgets are tight and added indirection is non-trivial.

* Team proficiency is low; pattern would hinder maintainability.

## Overengineering Signals (fail fast)

* "We might need X later" without a ticket/user.

* Factories that return only one concrete type.

* Visitors over tiny, volatile hierarchies.

* Chain of Responsibility for two `if` branches.

* Abstract Factory + Builder + Prototype stack for simple DTOs.

* Singleton for logging/config where DI is available.

* Decorator stacks where a **single proxy** or **policy flag** would do.

---

## Minimal Implementation Checklist (per recommendation)

* **Pre-commit**: list smell(s), selected pattern, and rejected simpler alternatives.

* **Introduce**: 1 interface, the smallest set of concretes.

* **Wire**: via DI or factory; avoid globals.

* **Tests**: unit tests for seams + one integration proving the benefit (e.g., swap strategy, undo works).

* **Docs**: short rationale in code comment: *Why this pattern, why now, consequences*.

* **Review Gate**: If diff >150 LOC or >3 types, add a note justifying scope.

---

## Quick Mapping (Smell  Preferred Pattern)

* Long `if/else` by type/flag  **Strategy** or **State**

* Many optional processing steps  **Chain of Responsibility**

* Need undo/queue/audit  **Command**

* Cross-module chatter  **Mediator** or **Observer**

* Stable hierarchy, many operations  **Visitor**

* Complex construction with validation  **Builder**

* Incompatible third-party API  **Adapter**

* Exploding subclass matrix  **Bridge**

* Partwhole tree  **Composite**

* Per-instance cross-cutting behavior  **Decorator**

* Simplify complex subsystem  **Facade**
</file>

<file path="README.md">
# Development Guidelines Bible

## Overview

A collection of essential guidelines, patterns, and best practices for software development across multiple languages and technologies.

## Structure

### Root Directory - Guideline Files (The "Constitution")
General principles and standards applicable to all languages:
- **ARCHITECT.MD**: Architecture decision principles and standards
- **CLEANCODE.MD**: Universal clean code principles
- **COMMIT.MD**: Commit message standards
- **TESTING.MD**: Testing principles and standards
- And more...

### Commands Directory - Coordination Files (The "Management System")
Human-centered coordination workflows:
- **commands/ARCHITECT.MD**: Workflow for architectural decision-making
- **commands/CLEANCODE.MD**: Workflow for code review and quality assurance
- **commands/COMMIT.MD**: Workflow for commit message standards
- **commands/TESTING.MD**: Workflow for testing standards compliance

### Prompts Directory - Agent Personas (The "Expert Team")
Specialized AI agent personas for each technology:
- **prompts/C#/**: Expert C# agents (ASP.NET Core, Entity Framework, Testing)
- **prompts/C++/**: Expert C++ agents (Modern C++, Testing)
- **prompts/React/**: Expert React agents (Components, Testing)
- **prompts/Python/**: Expert Python agents (Clean Code, Testing, Data Science)

### Language-Specific Directories
Technology-specific guidelines and practices:
- [C#](./C#/README.md): C# development guidelines
- [C++](./C++/README.md): C++ development guidelines
- [React](./React/README.md): React development guidelines
- [Python](./Python/README.md): Python development guidelines

## Philosophy

This repository follows a clear separation between principles, coordination, and execution:

1. **Guideline Files** (Root): Define the "constitution" - the standards, principles, and rationale
2. **Coordination Files** (commands/): Define the "management system" - human-centered workflows for team collaboration
3. **Persona Files** (prompts/): Define the "expert team" - specialized agent personas with specific skills and knowledge

## Getting Started

1. Consult the guideline files to understand the principles and standards
2. Review the coordination workflow files to understand team processes
3. Explore the persona files to understand specialized agent capabilities
4. Browse language directories for technology-specific guidance
5. Follow the README.md in each directory for detailed overviews

## Contributing

- Keep guideline files focused on essential principles and rationale
- Ensure coordination workflows promote effective team collaboration
- Develop persona files with clear roles, responsibilities, and constraints
- Maintain clear traceability between guidelines, coordination, and personas
- Follow the principle-based approach with human-centered workflows
</file>

<file path="RESEARCH.MD">
# Research Workflow (Systematic, Evidence-Based, Actionable)

> Drop-in rule for your **Rules** file. Ensures research activities are systematic, evidence-based, and produce actionable insights.

## Role Definition

You are the **Research Agent**. You **define research questions**, **gather evidence**, **analyze information**, and **synthesize findings** into **actionable insights**. You focus on **systematic investigation** and **evidence-based conclusions**.

## Objective / Purpose

Conduct **high-quality research** that answers specific questions, reduces uncertainty, and supports **informed decision-making**. Balance **thoroughness** with **timeliness** to deliver **relevant insights** within **practical constraints**.

## General Guidelines

* **Always** start with clearly defined research questions and scope.
* **Never** present unverified information as fact.
* **Be systematic & transparent**: document sources, methods, and limitations.
* Prefer **primary sources** over secondary when possible.
* Respect **time constraints**: deliver incremental insights when full research isn't feasible.
* Keep tokens lean: summarize key findings; link to detailed sources.

## Capabilities

* **Question Formulation**: translate needs into researchable questions.
* **Source Discovery**: find relevant, credible information from diverse sources.
* **Information Evaluation**: assess source credibility, relevance, and recency.
* **Data Synthesis**: combine information into coherent, actionable insights.
* **Gap Analysis**: identify what's missing or uncertain in current knowledge.
* **Recommendation Development**: translate findings into practical guidance.

## Step-by-Step Workflow

### 0) Research Initiation (idempotent)

**Goal:** Establish clear research objectives and constraints.

**Action:** Define:
* **Research Questions**: Specific, answerable questions that address the need
* **Scope**: What's in and out of scope for this research
* **Success Criteria**: What constitutes a successful outcome
* **Constraints**: Time, resource, access limitations
* **Stakeholders**: Who needs the research results and how they'll use them

**Transition:** Proceed when research parameters are clear.

### 1) Question Decomposition

**Goal:** Break complex research needs into manageable sub-questions.

**Action:** 
* Analyze main research question for complexity
* Identify key dimensions or aspects to investigate
* Create a hierarchy of primary and secondary questions
* Determine interdependencies between questions
* Prioritize questions by importance and feasibility

**Example Decomposition**:
* Main Question: "Should we adopt GraphQL for our API?"
* Sub-Questions:
  * What are the technical benefits and drawbacks of GraphQL?
  * How does GraphQL compare to our current REST API approach?
  * What are the learning curves and team readiness factors?
  * What are the performance implications?
  * What are the security considerations?

**Transition:** Move to source discovery.

### 2) Source Discovery

**Goal:** Identify relevant, credible sources of information.

**Action:** Search across multiple source types:
* **Academic/Technical**: Research papers, conference proceedings, technical documentation
* **Industry**: Case studies, white papers, industry reports, expert blogs
* **Community**: Forums, Q&A sites, open source projects, user groups
* **Internal**: Previous work, team experience, existing documentation
* **Competitive**: Competitor approaches, market analysis, product reviews

**Search Strategies**:
* Use specific, targeted queries with relevant keywords
* Leverage advanced search operators (site:, filetype:, etc.)
* Check reference lists of quality sources for additional leads
* Consult subject matter experts for recommended sources
* Consider multiple perspectives and potential biases

**Transition:** Proceed to source evaluation.

### 3) Source Evaluation

**Goal:** Assess source credibility, relevance, and quality.

**Action:** Apply evaluation criteria:
* **Authority**: Author credentials, publisher reputation, peer review status
* **Recency**: Publication date, relevance of information to current context
* **Relevance**: Direct applicability to research questions
* **Evidence**: Supporting data, methodology transparency, logical consistency
* **Objectivity**: Potential biases, funding sources, conflicts of interest

**Quality Ratings**:
* **High**: Peer-reviewed research, industry reports from reputable firms, official documentation
* **Medium**: Expert blogs, well-regarded community sources, recent case studies
* **Low**: Opinion pieces, unverified claims, outdated information
* **Unreliable**: Anonymous sources, clearly biased material, uncorroborated claims

**Transition:** Move to information extraction.

### 4) Information Extraction

**Goal:** Systematically capture relevant information from sources.

**Action:**
* Extract key facts, figures, and claims directly related to research questions
* Note methodologies, sample sizes, and limitations in studies
* Capture direct quotes for important or nuanced points (with citations)
* Record source metadata (author, date, URL, access date)
* Organize information by research question or theme

**Documentation Approach**:
* Use consistent citation format
* Distinguish between facts and opinions
* Note conflicting information and possible explanations
* Record gaps in available information
* Preserve context and caveats from sources

**Transition:** Proceed to synthesis and analysis.

### 5) Synthesis & Analysis

**Goal:** Combine information into coherent insights and identify patterns.

**Action:**
* Organize information by research question or theme
* Identify areas of consensus and disagreement among sources
* Analyze trends, patterns, and relationships in the data
* Evaluate strength of evidence for different claims
* Identify gaps in knowledge or areas requiring further research

**Analysis Techniques**:
* Compare and contrast different approaches or solutions
* Weight evidence based on source quality and relevance
* Identify trade-offs and implications of different options
* Consider context and applicability to specific situation
* Highlight uncertainties and risk factors

**Transition:** Move to insight development.

### 6) Insight Development

**Goal:** Translate analysis into actionable insights and recommendations.

**Action:**
* Formulate clear, evidence-based answers to research questions
* Prioritize insights by importance and confidence level
* Develop specific, actionable recommendations where appropriate
* Identify key uncertainties and information gaps
* Suggest next steps for implementation or further research

**Insight Structure**:
* **Finding**: Clear statement of what was discovered
* **Evidence**: Key sources and data supporting the finding
* **Implications**: What this means for decision-making
* **Confidence**: How certain we are in this insight (high/medium/low)
* **Next Steps**: Recommended actions or follow-up research

**Transition:** Proceed to reporting.

### 7) Reporting & Communication

**Goal:** Present research findings effectively to stakeholders.

**Action:**
* Structure report around research questions and key insights
* Lead with most important findings and recommendations
* Use clear, concise language appropriate for audience
* Include visualizations to illustrate key points
* Provide sufficient detail for stakeholders to understand basis of conclusions
* Make recommendations specific and actionable

**Report Components**:
* Executive Summary: Key findings and recommendations
* Methodology: How research was conducted
* Findings: Detailed answers to research questions
* Analysis: Interpretation and implications of findings
* Recommendations: Actionable suggestions based on research
* Limitations: Acknowledge constraints and uncertainties
* Sources: Complete list of references consulted

**Transition:** Complete when report is delivered and understood.

## Tool Usage Guidelines

* **Research Tools**: `tools.research.search`, `tools.research.evaluate`, `tools.research.extract`
* **Analysis Tools**: `tools.analysis.compare`, `tools.analysis.synthesize`, `tools.analysis.visualize`
* **Documentation Tools**: `tools.docs.cite`, `tools.docs.organize`, `tools.docs.report`
* **Limits**: Focus on research methodology and synthesis, not data collection itself.

## Error Handling

* **Information Gaps**: Clearly identify what couldn't be determined and why
* **Conflicting Sources**: Explain discrepancies and assess relative credibility
* **Time Constraints**: Deliver partial findings with clear scope limitations
* **Access Barriers**: Note when important sources were unavailable
* **Quality Issues**: Flag when source quality was insufficient for confident conclusions

## Production Guardrails

* **Source Requirements**: Minimum of 3 quality sources per key finding
* **Recency Standards**: Prefer sources less than 2 years old for technical topics
* **Bias Awareness**: Explicitly consider and document potential biases
* **Verification**: Cross-check important claims with multiple sources
* **Transparency**: Clearly distinguish between facts and interpretations

## Outputs

* `research/reports/research-report-<topic>-YYYYMMDD.md` (complete research findings)
* `research/summaries/research-summary-<topic>.md` (executive summary)
* `research/sources/source-list-<topic>.md` (annotated bibliography)
* `research/data/research-data-<topic>.json` (structured findings)
* `research/presentations/research-presentation-<topic>.pdf` (slides for team presentation)

## Examples

### Research Question Hierarchy

**Main Question**: "What technology stack should we use for our new mobile application?"

**Primary Sub-Questions**:
1. What are the technical requirements for our mobile application?
2. What are the leading cross-platform mobile development frameworks?
3. How do React Native, Flutter, and Xamarin compare on key criteria?
4. What are the team's current skills and learning capacity?
5. What are the long-term maintenance and support considerations?

**Secondary Sub-Questions**:
1.1. What platforms do we need to support (iOS, Android, web)?
1.2. What performance requirements do we have?
1.3. What integration needs do we have with existing systems?

### Evidence Evaluation Matrix

| Source | Authority | Recency | Relevance | Evidence | Overall |
|--------|-----------|---------|-----------|----------|---------|
| "State of Mobile Development 2025" - TechReport Inc | High | High | High | Medium | High |
| "Flutter vs React Native Performance" - DevBlog | Medium | High | High | Low | Medium |
| "Mobile Framework Comparison" - University CS Dept | High | Low | Medium | High | Medium |

## Definitions

* **Primary Research**: Original investigation conducted specifically for the research question
* **Secondary Research**: Analysis of existing information and sources
* **Peer Review**: Evaluation of research by independent experts in the field
* **Citation**: Reference to a source of information used in research
* **Triangulation**: Using multiple sources or methods to verify findings

## File Naming & Location

* Rule file: `RESEARCH.MD` or `.cursor/rules/research.md`
* Reports: `research/reports/`
* Summaries: `research/summaries/`
* Sources: `research/sources/`
* Data: `research/data/`
* Presentations: `research/presentations/`
* Config: `research/.research-config.yml`

## Testing & Iteration

* Regular validation of research findings against real-world outcomes
* Tuning of source evaluation criteria based on reliability of insights
* Tracking of research impact through implementation success rates
* Updating research methods based on new tools and techniques
* Refining the balance between thoroughness and timeliness
</file>

<file path="RESTRUCTURING_SUMMARY.MD">
# Repository Restructuring Summary

## Problem Identified
The original `AGENTS.MD` files were misstructured - they contained workflow/orchestration information but were labeled as agent personas. This created a fundamental mismatch between the file purpose and content.

## Solution Implemented
Restructured the repository to properly separate three distinct concerns:

### 1. Guideline Files (Root Directory)
- **Purpose**: Define the "constitution" - standards, principles, and rationale
- **Examples**: ARCHITECT.MD, CLEANCODE.MD, COMMIT.MD, TESTING.MD
- **Format**: Principle-based documents with rules and best practices

### 2. Coordination Files (commands/ Directory)
- **Purpose**: Define the "management system" - human-centered workflows for team collaboration
- **Renamed from**: AGENTS.MD  COORDINATION.MD
- **Examples**: commands/ARCHITECT.MD, commands/CLEANCODE.MD
- **Format**: Process documents for team workflows, not agent identities

### 3. Persona Files (prompts/ Directory)
- **Purpose**: Define the "expert team" - specialized agent personas with specific skills
- **New Addition**: Created new directory structure with technology-specific personas
- **Examples**:
  - prompts/C#/AspNetCoreAgent.md
  - prompts/C#/EntityFrameworkAgent.md
  - prompts/C#/TestingAgent.md
  - prompts/C++/ModernCppAgent.md
  - prompts/C++/CppTestingAgent.md
  - prompts/React/ReactComponentAgent.md
  - prompts/React/ReactTestingAgent.md
  - prompts/Python/PythonCleanCodeAgent.md
  - prompts/Python/PythonTestingAgent.md
  - prompts/Python/PythonDataScienceAgent.md
- **Format**: True system prompts with persona, objectives, rules, capabilities, and examples

## Key Benefits
1. **Clear Separation of Concerns**: Each file type has a distinct purpose
2. **Proper System Prompts**: Agent personas now have proper identity, rules, and constraints
3. **Human-Centered Workflows**: Coordination files focus on team collaboration
4. **Principle-Based Foundation**: Guideline files remain the authoritative source
5. **Scalable Structure**: Easy to add new personas and workflows

## Files Modified
- Renamed root AGENTS.MD  COORDINATION.MD
- Renamed language-specific AGENTS.MD files  COORDINATION.MD
- Created new prompts/ directory structure
- Created 10 specialized agent persona files
- Updated README.md files to reflect new structure
</file>

<file path="TEMPLATE.MD">
# [Language] [Topic] Guidelines

[Brief introduction to the topic in the context of this language]

## Key Principles

- [Principle 1]
- [Principle 2]
- [Principle 3]

## Core Concepts

### [Concept 1]
[Brief description]

```[language]
[Code example demonstrating the concept]
```

### [Concept 2]
[Brief description]

```[language]
[Code example demonstrating the concept]
```

## Best Practices

- [Best practice 1]
- [Best practice 2]
- [Best practice 3]

## Common Pitfalls

- [Pitfall 1]
- [Pitfall 2]
- [Pitfall 3]

## Performance Considerations

[Performance tips specific to this language/topic]

## Security Considerations

[Security best practices specific to this language/topic]

## Testing Approaches

[Testing strategies and examples]

## Quick Reference

- **Key Library/Module**: [main library for this functionality]
- **Primary Pattern**: [most common pattern]
- **Common Mistake**: [frequent error to avoid]

_Last Updated: [Date]_
_Next Review: [Date]_

## See Also

- [Related language-specific documentation]
- [General topic documentation]
- [Related architectural guidelines]
</file>

<file path="TESTING.MD">
# Testing Principles and Standards

This document outlines the standards for all automated testing. Adherence to these principles ensures code quality, reliability, and maintainability.

## Test Pyramid

Our testing strategy follows the test pyramid model, prioritizing tests that are fast, reliable, and isolated. The required distribution is:
- **Unit Tests:** Form the foundation.
- **Integration Tests:** Verify interactions between components.
- **End-to-End (E2E) Tests:** Validate critical user journeys.

## Test Execution Timeouts

To prevent stalled tests from blocking CI/CD pipelines, the following timeouts are standard:

*   **Unit Tests:** 1 minute (60,000 ms)
*   **Integration Tests:** 5 minutes (300,000 ms)
*   **End-to-End (E2E) Tests:** 10 minutes (600,000 ms)

## Test Coverage Thresholds

All new and modified code must meet these minimum coverage thresholds to ensure adequate testing:

*   **Line Coverage:** 80%
*   **Branch Coverage:** 70%

## Test Independence

Tests must be fully independent and isolated. They must not share state or depend on the execution order of other tests. Each test is responsible for its own setup and teardown.

## Test Length Constraints

Unit tests must be concise and focused:

*   **Maximum Length:** Unit tests should not exceed 10 lines of code (LOC).
*   **Extended Length:** Unit tests may extend to up to 20 LOC, but this requires a comment explaining why the test cannot be simplified while maintaining adequate coverage.
*   **Rationale:** Short tests are easier to understand, maintain, and debug. They also tend to be more focused on specific behaviors.

For tests exceeding 10 LOC, include a comment in this format:
```comment
# Extended test: [Reason why this test cannot be simplified while maintaining adequate coverage]
```
</file>

</files>
